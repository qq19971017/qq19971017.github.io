<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA String详解</title>
    <url>/2020/08/01/JAVA-String%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一-String概念"><a href="#一-String概念" class="headerlink" title="一. String概念"></a>一. String概念</h3><p>String 是java中对字符串的一种表达方式，这是一个示例对象，并不属于常见的8中基本类型，和char[]也有一定的区别。</p>
<h4 id="1-String特性"><a href="#1-String特性" class="headerlink" title="1.String特性"></a>1.String特性</h4><p>String有三个特性。</p>
<ul>
<li><p>不可变性：从JDK文档中我们可以看到，String是常量的，这就意味着当我们对String重新赋值的时候，需要重写指定内存区域进行赋值，不能对原有的内存地址中的value进行修改。当对现有的字符串进行拼接的时候，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。当我们调用String的replace()方法进行修改的时候，同样的也不能直接修改</p>
</li>
<li><p>final 修饰：这意味这String是不可以被继承的，这也增加了String的安全性。实现Serializable接口：表示字符串支持序列化，实现了ComparaBle接口：表示String可以比较大小；</p>
</li>
<li><p>在JVM中维护了一个字符串常量池，用于存放字符串常量，这个对于我们深入理解String是非常重要的，至于字符串常量池的版本变化，我在之前的方法区中有提到过，大家可以去看一下。通过字面量的方式(区别与new)给一个字符串赋值，此时的字符串值声明在字符串常量池中。当然根据字符串常量池的特性，常量池中是不会存放相同的值，当我们创建两个具有相同字面量的字符串时，比如</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>

<p>因为字符串a和字符串b被同一个字面量创建，当a被创建的时候，会先检查字符串常量池中是否有“abc”，如果没有则开辟一个空间并把“abc”存放到这个地址上，而当b被创建的时候，检查常量池上已经有“abc”了，所以直接把指针指向该地址。实际上a和b指向的是同一个地址。</p>
<h4 id="2-String内存分配"><a href="#2-String内存分配" class="headerlink" title="2.String内存分配"></a>2.String内存分配</h4><p>在Java语言中，有8种基本类型，和一种比较特殊的类型String，这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。<br>常量池就是类似一个Java系统级别的提供的缓存。8中基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它主要使用的方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li>
</ul>
<h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p>String操作有：字符串的创建、拼接、比较等几个比较常用的方法，这些方法的一些用法因为String的特殊性，经常被当作笔试的题目，我们接下来就重点讲解这几个操作。</p>
<h4 id="1-String创建"><a href="#1-String创建" class="headerlink" title="1.String创建"></a>1.String创建</h4><p>String的创建有两种方法，一种是使用字面量赋值，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式创建字符串，会直接在常量池中创建对象，栈对象a和b分别用指针指向该字符串常量池中的常量。</p>
<p>另一种方式是使用常用的new关键字创建，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式创建的字符串会先在堆中开辟一个空间，并创建字符串对象c，这个对象的value为“abc”，同时会检查常量池是否含有“abc”字符串，如果没有的话会重新创建一个字符串常量“abc”。</p>
<p>总结来说第一种创建方法指针会直接指向字符串常量池相当于a-&gt;”abc”,b-&gt;”abc”，第二种方式首先会在堆中创建一个c的String对象，它的value是“abc”。 同时如果这个字符串在常量池中不存在，会在常量池中创建这个String对象“abc”；</p>
<p>我们用下图表示，两者的区别：</p>
<p><img src="/images/pasted-53.png" alt="upload successful"></p>
<p>所以我们可以看到这样的面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(a == c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的结果是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-String拼接"><a href="#2-String拼接" class="headerlink" title="2.String拼接"></a>2.String拼接</h4><p>常量池的拼接遵守以下规则：</p>
<ul>
<li>1.常量和常量的拼接结果在常量池中，原理是编译期优化。</li>
<li>2.常量池中不会存在相同内容的常量。</li>
<li><ol start="3">
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。</li>
</ol>
</li>
<li>4.如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放在常量池中，并返回此对象地址。</li>
</ul>
<p>下面我们根据一些笔试的题目看一下这些规则：<br>面试题一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String a = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    String b = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(a ==b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里a是由三个字符串拼接的结果，我们根据规则一可以得到拼接结果“abc”会放在常量池中，所以结果阿返回的是true，并且我们根据编译的class文件可以看到，String a = “a” + “b” + “c”;直接会被优化成String a = “abc”;所以最后执行的代码是String a = “abc”；这样我们可以和我们之间的知识对应。</p>
<p>面试题二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">"a"</span>;</span><br><span class="line">    String s2 = <span class="string">"b"</span>;</span><br><span class="line">    String s3 = <span class="string">"ab"</span>;</span><br><span class="line">    String s4 = <span class="string">"a"</span>+<span class="string">"b"</span>;</span><br><span class="line">    String s5 = s1+<span class="string">"b"</span>;</span><br><span class="line">    String s6 = <span class="string">"a"</span>+s2;</span><br><span class="line">    String s7 = s1+s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的规则得到，只要其中有一个是变量，得到的结果就存放在堆中，而不是在常量池中，所以除了当一个返回的是true，其他的返回的都是false。</p>
<p>当我们使用变量进行拼接的时候，我们使用的底层是StringBilder，比如上面的String s7 = s1+s2;就相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"a"</span>);</span><br><span class="line">sb.append(<span class="string">"b"</span>);</span><br><span class="line">sb.toString();</span><br></pre></td></tr></table></figure>
<p>StringBuilder的toString操作实际上是一个new String的操作。</p>
<p>当然不是所有的变量拼接操作都是使用StringBuilder操作的，当我们对变量声明为final的时候，变量的拼接就会编程常量的拼接，这样底层就不会用到SringBuilder，而是由编译器优化直接使用常量池进行赋值。</p>
<p>这里同时也变相说明了String的拼接操作会比StringBuilder的拼接操作效率低，因为String在进行拼接操作的过程中会new StringBuilder对象，然后再进行拼接操作，而StringBuilder直接进行拼接，节省了空间和时间从而提高效率。</p>
<p>讲完上面两个String的创建和拼接，我们来看一个综合的笔试面试题目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     String a = <span class="keyword">new</span> String(<span class="string">"a"</span>)+ <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们来计算一下这里到底创建了多少个对象，我们先说答案，再说为什么，这里一共生成了6个对象。<br>首先是会生成一个StringBuilder对象用于拼接，接着对于new String(a)会在堆中以及常量分别生成String对象，以及对于new String(“b”)同样的会生成两个对象，最后调用StringBuilder的toString方法，会生成一个String对象。这里要注意，toString方法并不会在常量池中生成对象，所以常量池中并没有“ab”的字符串对象。</p>
<h4 id="3-intern"><a href="#3-intern" class="headerlink" title="3.intern()"></a>3.intern()</h4><p>String字符串还有一个比较特殊的API：intern()，当一个字符串s调用这个函数的时候，会从字符串常量池中寻找是否有与s值相等的字符串，如果找到了，就返回常量池中的字符串。否则，将该字符串加入到常量池中，并且返回对该常量池中这个字符串的引用。</p>
<p>比如说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String info = <span class="keyword">new</span> String(<span class="string">"1111"</span>).intern();</span><br></pre></td></tr></table></figure>

<p>也就是说，如果在任意字符串上调用String.intern方法，那么返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同，因此，下列表达式的值必定是true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>&#125;.intern()== “abc”；</span><br></pre></td></tr></table></figure>
<p>通俗来讲，Intern就是确保相同值的字符串在内存中只用一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意这个值会被存放在字符串内部池。</p>
<p>这里我们仍然用一个面试题来看一下intern()方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String a = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">    a.intern();</span><br><span class="line">    String b = <span class="string">"ab"</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题的答案其实根据不同的jdk版本是不一样的，在jdk1.6以前，因为之前说过String a = new String(“a”) + new String(“b”);并没有在常量池中创建“ab”的字符串，且a指向的是堆空间地址，所以返回的是false，但是在jdk7及以后，intern同样会在常量池中寻找“ab”对象，但是因为在堆中已经创建了“ab”的字符串对象，所以当b创建对象的时候，常量池不需要在常量池中重新创建“ab”对象了，可以直接存储堆中的引用，这个引用指向s3引用的对象，也就是说引用地址相同。所以结果最终返回的是true。</p>
<p>当我们将a.intern();和String b = “ab”;调换一下顺序之后，结果又会发生变化，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String a = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">    String b = <span class="string">"ab"</span>;</span><br><span class="line">    a.intern();</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为String b = “ab”;并不会像a.intern()一样智能会选择直接引用堆中相同的对象，所以结果返回的就是false；</p>
<h4 id="4-String-比较"><a href="#4-String-比较" class="headerlink" title="4.String 比较"></a>4.String 比较</h4><p>String的比较主要有两种，一种是==一种是equals。</p>
<ul>
<li>使用==号：用于比较对象引用的内存地址是否相同。</li>
<li>使用equals方法：在Object类中和==号相同，但在自定义类中，建议覆盖equals方法去实现比较自己内容的细节；由于String类覆盖已经覆盖了equals方法，所以其比较的是字符内容。</li>
</ul>
<h3 id="三-StringBuffer-和-StringBuilder"><a href="#三-StringBuffer-和-StringBuilder" class="headerlink" title="三. StringBuffer 和 StringBuilder"></a>三. StringBuffer 和 StringBuilder</h3><p>StringBuffer和StringBuilder常常用于解决字符串拼接的问题，他们都比String直接凭借效率高很多。</p>
<p>先来分别使用String/StringBuilder/StringBuffer来拼接30000次字符串，对比各自损耗的时间，经过测试发现：</p>
<p>String做字符串拼接的时候，耗时最高，性能极低，原因是String内容是不可变的，每次内容改变都会在内存中创建新的对象。</p>
<p>性能最好的是StringBuilder，其次是StringBuffer，最后是String。StringBuilder和StringBuffer区别并不是很大，也有可能是测试次数还不够吧。感兴趣的小伙伴可以增加拼接次数来看看。代码很简单，就不展示出来了。</p>
<p>所以在开发中拼接字符串时，优先使用StringBuffer/StringBuilder，不到万不得已，不要轻易使用String。</p>
<h4 id="StringBuilder以及StringBuffer的区别"><a href="#StringBuilder以及StringBuffer的区别" class="headerlink" title="StringBuilder以及StringBuffer的区别"></a>StringBuilder以及StringBuffer的区别</h4><p>StringBuffer和StringBuilder都表示可变的字符串，两种’的功能方法都是相同的。但唯一的区别：</p>
<ul>
<li>StringBuffer：StringBuffer中的方法都使用了synchronized修饰符，表示同步操作，在多线程并发的时候可以保证线程安全，但在保证线程安全的时候，对其性能有一定影响，会降低其性能。</li>
<li>StringBuilder：StringBuilder中的方法都没有使用了synchronized修饰符，线程不安全，正因为如此，其性能较高。</li>
</ul>
<p>对并发安全没有很高要求的情况下，建议使用StringBuilder，因为其性能很高。像这样的情况会较多些。使用StringBuilder无参数的构造器，在底层创建了一个长度为16的char数组：</p>
<p><img src="/images/pasted-54.png" alt="upload successful"></p>
<p>此时该数组只能存储16个字符，如果超过了16个字符，会自动扩容（创建长度更大的数组,再把之前的数组拷贝到新数组），此时性能极低；如果事先知道大概需要存储多少字符，可以通过构造器来设置字符的初始值：</p>
<p><img src="/images/pasted-55.png" alt="upload successful"></p>
<h3 id="四-参考资料"><a href="#四-参考资料" class="headerlink" title="四. 参考资料"></a>四. 参考资料</h3><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ?t=428&p=131" target="_blank" rel="noopener">尚硅谷2020最新版宋红康JVM教程持续更新中(java虚拟机详解，jvm从入门到精通)
</a></p>
<p><a href="https://segmentfault.com/a/1190000022468585" target="_blank" rel="noopener">「JAVA」细述合理创建字符串，分析字符串的底层存储，你不该错过</a></p>
<p><a href="https://blog.csdn.net/weixin_40304387/article/details/81071816" target="_blank" rel="noopener">字符串常量池深入解析
</a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)JAVA 内存泄露详解（原因、例子及解决）</title>
    <url>/2020/06/16/%E8%BD%AC-JAVA-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%8E%9F%E5%9B%A0%E3%80%81%E4%BE%8B%E5%AD%90%E5%8F%8A%E8%A7%A3%E5%86%B3%EF%BC%89/</url>
    <content><![CDATA[<p>文章转自<a href="http://blog.csdn.net/anxpp/article/details/51325838" target="_blank" rel="noopener">JAVA 内存泄露详解（原因、例子及解决）</a></p>
<p>Java的一个重要特性就是通过垃圾收集器(GC)自动管理内存的回收，而不需要程序员自己来释放内存。理论上Java中所有不会再被利用的对象所占用的内存，都可以被GC回收，但是Java也存在内存泄露，但它的表现与C++不同。</p>
<h3 id="JAVA中的内存管理"><a href="#JAVA中的内存管理" class="headerlink" title="JAVA中的内存管理"></a>JAVA中的内存管理</h3><p>要了解Java中的内存泄露，首先就得知道Java中的内存是如何管理的。</p>
<p>在Java程序中，我们通常使用new为对象分配内存，而这些内存空间都在堆（Heap）上。</p>
<p>下面看一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Object object1 = <span class="keyword">new</span> Object();<span class="comment">//obj1</span></span><br><span class="line">        Object object2 = <span class="keyword">new</span> Object();<span class="comment">//obj2</span></span><br><span class="line">        object2 = object1;</span><br><span class="line">        <span class="comment">//...此时，obj2是可以被清理的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>Java使用有向图的方式进行内存管理</strong></p>
<p> 在有向图中，我们叫作obj1是可达的，obj2就是不可达的，显然不可达的可以被清理。</p>
<p>   内存的释放，也即清理那些不可达的对象，是由GC决定和执行的，所以GC会监控每一个对象的状态，包括申请、引用、被引用和赋值等。<strong>释放对象的根本原则就是对象不会再被使用：</strong></p>
<ul>
<li><p>给对象赋予了空值null，之后再没有调用过。</p>
</li>
<li><p>另一个是给对象赋予了新值，这样重新分配了内存空间。<br>通常，会认为在堆上分配对象的代价比较大，但是GC却优化了这一操作：C++中，在堆上分配一块内存，会查找一块适用的内存加以分配，如果对象销毁，这块内存就可以重用；而Java中，就想一条长的带子，每分配一个新的对象，Java的“堆指针”就向后移动到尚未分配的区域。所以，Java分配内存的效率，可与C++媲美。</p>
<p>但是这种工作方式有一个问题：如果频繁的申请内存，资源将会耗尽。这时GC就介入了进来，它会回收空间，并使堆中的对象排列更紧凑。这样，就始终会有足够大的内存空间可以分配。</p>
<p>gc清理时的引用计数方式：当引用连接至新对象时，引用计数+1；当某个引用离开作用域或被设置为null时，引用计数-1，GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。</p>
<p>多数GC采用一种自适应的清理方式（加上其他附加的用于提升速度的技术），主要依据是找出任何“活”的对象，然后采用“自适应的、分代的、停止-复制、标记-清理”式的垃圾回收器。具体不介绍太多，这不是本文重点。</p>
</li>
</ul>
<h3 id="JAVA-中的内存泄露"><a href="#JAVA-中的内存泄露" class="headerlink" title="JAVA 中的内存泄露"></a>JAVA 中的内存泄露</h3><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。</p>
<p>Java中的内存泄露与C++中的表现有所不同。</p>
<p>在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个析构函数，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。</p>
<p>但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。</p>
<p>我们知道，对象都是有生命周期的，有的长，有的短，<strong>如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</strong>我们举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Object object;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。当然，如果一定要这么写，可以改为这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Object object;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，之前“new Object()”分配的内存，就可以被GC回收。</p>
<p>到这里，Java的内存泄露应该都比较清楚了。下面再进一步说明：</p>
<ul>
<li>在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值），这是针对c++等语言的，Java中的GC会帮我们处理这种情况，所以我们无需关心。</li>
<li>在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用），这是所有语言都有可能会出现的内存泄漏方式。编程时如果不小心，我们很容易发生这种情况，如果不太严重，可能就只是短暂的内存泄露。</li>
</ul>
<h3 id="一些容易发生内存泄露的例子和解决方法"><a href="#一些容易发生内存泄露的例子和解决方法" class="headerlink" title="一些容易发生内存泄露的例子和解决方法"></a>一些容易发生内存泄露的例子和解决方法</h3><p>像上面例子中的情况很容易发生，也是我们最容易忽略并引发内存泄露的情况，解决的原则就是尽量减小对象的作用域（比如android studio中，上面的代码就会发出警告，并给出的建议是将类的成员变量改写为方法内的局部变量）以及手动设置null值。</p>
<p> 至于作用域，需要在我们编写代码时多注意；null值的手动设置，我们可以看一下Java容器LinkedList源码（可参考：<a href="https://blog.csdn.net/anxpp/article/details/51203591" target="_blank" rel="noopener">Java之LinkedList源码解读（JDK 1.8）</a>）的删除指定节点的内部方法：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定节点并返回被删除的元素值</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前值和前后节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next; <span class="comment">//如果前一个节点为空(如当前节点为首节点)，后一个节点成为新的首节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;<span class="comment">//如果前一个节点不为空，那么他先后指向当前的下一个节点</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev; <span class="comment">//如果后一个节点为空(如当前节点为尾节点)，当前节点前一个成为新的尾节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;<span class="comment">//如果后一个节点不为空，后一个节点向前指向当前的前一个节点</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了修改节点间的关联关系，我们还要做的就是赋值为null的操作，不管GC何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象。</p>
<p>我们知道Java容器ArrayList是数组实现的（可参考：<a href="https://blog.csdn.net/anxpp/article/details/51203591" target="_blank" rel="noopener">Java之ArrayList源码解读（JDK 1.8）</a>），如果我们要为其写一个pop()（弹出）方法，可能会是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[--size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法很简洁，但这里却会造成内存溢出：elementData[size-1]依然持有E类型对象的引用，并且暂时不能被GC回收。我们可以如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        E e = (E) elementData[--size];</span><br><span class="line">        elementData[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们写代码并不能一味的追求简洁，首要是保证其正确性。</p>
<h3 id="容器使用时的内存泄露"><a href="#容器使用时的内存泄露" class="headerlink" title="容器使用时的内存泄露"></a>容器使用时的内存泄露</h3><p>在很多文章中可能看到一个如下内存泄露例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能很多人一开始并不理解，下面我们将上面的代码完整一下就好理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        vector.add(object);</span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...对vector的操作</span></span><br><span class="line">    <span class="comment">//...与vector无关的其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里内存泄露指的是在对vector操作完成之后，执行下面与vector无关的代码时，如果发生了GC操作，这一系列的object是没法被回收的，而此处的内存泄露可能是短暂的，因为在整个method()方法执行完成后，那些对象还是可以被回收。这里要解决很简单，手动赋值为null即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        vector.add(object);</span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...对v的操作</span></span><br><span class="line">    vector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...与v无关的其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面Vector已经过时了，不过只是使用老的例子来做内存泄露的介绍。我们使用容器时很容易发生内存泄露，就如上面的例子，不过上例中，容器时方法内的局部变量，造成的内存泄漏影响可能不算很大（但我们也应该避免），但是，如果这个容器作为一个类的成员变量，甚至是一个静态（static）的成员变量时，就要更加注意内存泄露了。</p>
<p>下面也是一种使用容器时可能会发生的错误:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMemory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String s[])</span></span>&#123;</span><br><span class="line">        Set&lt;MyObject&gt; objects = <span class="keyword">new</span> LinkedHashSet&lt;MyObject&gt;();</span><br><span class="line">        objects.add(<span class="keyword">new</span> MyObject());</span><br><span class="line">        objects.add(<span class="keyword">new</span> MyObject());</span><br><span class="line">        objects.add(<span class="keyword">new</span> MyObject());</span><br><span class="line">        System.out.println(objects.size());</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            objects.add(<span class="keyword">new</span> MyObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置默认数组长度为99999更快的发生OutOfMemoryError</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">99999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码将很快报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.ArrayList.&lt;init&gt;(ArrayList.java:152)</span><br><span class="line">at com.anxpp.memory.MyObject.&lt;init&gt;(CollectionMemory.java:21)</span><br><span class="line">at com.anxpp.memory.CollectionMemory.main(CollectionMemory.java:16)</span><br></pre></td></tr></table></figure>

<p>  如果足够了解Java的容器，上面的错误是不可能发生的。这里也推荐一篇本人介绍Java容器的文章：…</p>
<p>  容器Set只存放唯一的元素，是通过对象的equals()方法来比较的，但是Java中所有类都直接或间接继承至Object类，Object类的equals()方法比较的是对象的地址，上例中，就会一直添加元素直到内存溢出。</p>
<p>  所以，上例严格的说是容器的错误使用导致的内存溢出。</p>
<p>  就Set而言，remove()方法也是通过equals()方法来删除匹配的元素的，如果一个对象确实提供了正确的equals()方法，但是切记不要在修改这个对象后使用remove(Object o)，这也可能会发生内存泄露。</p>
<h3 id="各种提供了close-方法的对象"><a href="#各种提供了close-方法的对象" class="headerlink" title="各种提供了close()方法的对象"></a>各种提供了close()方法的对象</h3><p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，以及使用其他框架的时候，除非其显式的调用了其close()方法（或类似方法）将其连接关闭，否则是不会自动被GC回收的。其实原因依然是长生命周期对象持有短生命周期对象的引用。</p>
<p>可能很多人使用过Hibernate，我们操作数据库时，通过SessionFactory获取一个session：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Session session=sessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.close();</span><br></pre></td></tr></table></figure>

<p> SessionFactory就是一个长生命周期的对象，而session相对是个短生命周期的对象，但是框架这么设计是合理的：它并不清楚我们要使用session到多久，于是只能提供一个方法让我们自己决定何时不再使用。</p>
<p> 因为在close()方法调用之前，可能会抛出异常而导致方法不能被调用，我们通常使用try语言，然后再finally语句中执行close()等清理工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    session=sessionFactory.openSession();</span><br><span class="line">    <span class="comment">//...其他操作</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例模式导致的内存泄露"><a href="#单例模式导致的内存泄露" class="headerlink" title="单例模式导致的内存泄露"></a>单例模式导致的内存泄露</h3><p>单例模式，很多时候我们可以把它的生命周期与整个程序的生命周期看做差不多的，所以是一个长生命周期的对象。如果这个对象持有其他对象的引用，也很容易发生内存泄露。</p>
<h3 id="内部类和外部模块的引用"><a href="#内部类和外部模块的引用" class="headerlink" title="内部类和外部模块的引用"></a>内部类和外部模块的引用</h3><p>其实原理依然是一样的，只是出现的方式不一样而已。</p>
<h3 id="与清理相关的方法"><a href="#与清理相关的方法" class="headerlink" title="与清理相关的方法"></a>与清理相关的方法</h3><p>本节主要谈论gc()和finalize()方法。</p>
<h4 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h4><p>对于程序员来说，GC基本是透明的，不可见的。运行GC的函数是System.gc()，调用后启动垃圾回收器开始清理。</p>
<p>但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。</p>
<p>JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p> finalize()是Object类中的方法。</p>
<p>了解C++的都知道有个析构函数，但是注意，finalize()绝不等于C++中的析构函数。</p>
<p>Java编程思想中是这么解释的：一旦GC准备好释放对象所占用的的存储空间，将先调用其finalize()方法，并在下一次GC回收动作发生时，才会真正回收对象占用的内存，所以一些清理工作，我们可以放到finalize()中。</p>
<p>该方法的一个重要的用途是：当在java中调用非java代码（如c和c++）时，在这些非java代码中可能会用到相应的申请内存的操作（如c的malloc()函数），而在这些非java代码中并没有有效的释放这些内存，就可以使用finalize()方法，并在里面调用本地方法的free()等函数。</p>
<p>所以finalize()并不适合用作普通的清理工作。</p>
<p>不过有时候，该方法也有一定的用处：</p>
<p>如果存在一系列对象，对象中有一个状态为false，如果我们已经处理过这个对象，状态会变为true，为了避免有被遗漏而没有处理的对象，就可以使用finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...一些处理操作</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!state)&#123;</span><br><span class="line">            System.out.println(<span class="string">"ERROR:"</span> + <span class="string">"对象未处理！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是从很多方面了解，该方法都是被推荐不要使用的，并被认为是多余的。</p>
<p>
总的来说，内存泄露问题，还是编码不认真导致的，我们并不能责怪JVM没有更合理的清理。






]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记(5)——方法区</title>
    <url>/2020/06/15/JVM/</url>
    <content><![CDATA[<blockquote>
<p>今天把宋红康老师的JVM内存结构的方法区看完了，至此所有的内存结构都已经系统的学习一遍了，我也在博客中整理和回顾一下我的学习笔记。ps：本来打算昨天就写blog的，结果在准备今天项目的时候遇到了一些问题，真心发现硬件实践要比算法难很多，所以也给我一个警惕，不仅要关注上层的算法知识，也要多关注底层的硬件，多考虑如何将算法落地。</p>
</blockquote>
<h3 id="一-方法区概念"><a href="#一-方法区概念" class="headerlink" title="一. 方法区概念"></a>一. 方法区概念</h3><p><img src="/images/pasted-46.png" alt="upload successful"><br>我们之前也提到了JVM的内存结构，分为堆、方法区、本地方法栈、虚拟机栈、程序计数器。如果按照线程是否共享来说，方法区和堆是线程共享的，而本地方法栈、虚拟机栈、程序计数器都是线程私有的。方法区和堆一样，在JVM启动的时候就被创建了，并且它的实际物理内存空间中和堆一样是不连续的。方法区是用于存储已被虚拟机加载的类信息、常量、静态变量、计时编译器编译后的代码等。方法区的大小决定了系统可以保存多少类，如果系统定义了太多的类，导致方法区的溢出，虚拟机同样会抛出内存异常错误：java.lang.OutOfMemoryError:MetaSpace。</p>
<p>方法区在java1.8版本之前都是叫做永久代，从1.8开始永久代被弃用，转而变成了元空间，其一些属性也发生了一些变化，在永久代的时候我们需要设置-XX:PermSize -XX:MaxPermSize来分别设置永久代初始值和最大值，当变成元空间之后，不再使用JVM的内存，转而使用本地内存来存储方法区的信息。其默认大小就是本地内存的大小，当然我们仍然可以设置元空间的初始值和最大值，当达到初始值的时候会触发full GC，当到达最大值并且full gc也满足不了需求的时候会触发OOM。比如说我们一直用动态代理创建对象或者一直往常量池加入数据，就有可能发生方法区内存溢出。当然关于触发了OOM，到底是内存泄漏导致的还是内存溢出导致的，这个还需要我们去探讨一下。我们可以看一下知乎的回答<a href="https://www.zhihu.com/question/40560123" target="_blank" rel="noopener">内存泄漏和内存溢出有啥区别？</a>(ps:内存泄漏可能会导致频繁进行full GC)</p>
<h4 id="1-方法区的内部结构"><a href="#1-方法区的内部结构" class="headerlink" title="1. 方法区的内部结构"></a>1. 方法区的内部结构</h4><p><img src="/images/pasted-47.png" alt="upload successful"><br>我们之前提到了，方法区内部存储有类信息和运行时常量池、字符串常量池、静态变量。其中静态变量和字符串常量池在java1.7之后放在堆中进行处理，后面我们会进行详细的分析。</p>
<p><img src="/images/pasted-48.png" alt="upload successful"><br>一个经典的堆内部结构还会有域信息和方法信息，但是我们通常将域信息和方法信息放在类型信息中。</p>
<p><strong>类型信息</strong><br>对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>1.这了类型完整的有效名称(全名=包名、类名)</li>
<li>2.这个类型的直接父类的完整有效名（对于interface、或者是java.lang.Object都没有父类）</li>
<li>3.这个类型的修饰符（public abstruct、final的子集）</li>
<li>4.这个类型的直接接口的一个有序序列</li>
</ul>
<p><strong>方法信息</strong><br>JVM必须保存所有方法信息，同域信息一样包括声明顺序</p>
<ul>
<li>1.方法名称</li>
<li>2.方法的返回类型（或void）</li>
<li>3.方法参数的数量和类型（按顺序）</li>
<li>4.方法的修饰符（public、private、protected、static、final、synchroized、native、abstract）</li>
<li>5.方法的字节码（bytecodes）、操作数栈、局部变量表大小（abstract和netive方法除外）</li>
<li>6.异常表（abstract和native除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移位置、被捕获的异常累的常量池检索。</li>
</ul>
<p><strong>non-final的类变量</strong><br>静态变量和类变量关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。类变量被类的所有实例一起分享，即使没有类实例时你也可以访问他。</p>
<p><img src="/images/pasted-49.png" alt="upload successful"></p>
<h4 id="2-常量池和运行时常量池"><a href="#2-常量池和运行时常量池" class="headerlink" title="2. 常量池和运行时常量池"></a>2. 常量池和运行时常量池</h4><p>常量池在字节码文件中，运行时常量池在方法区中，这两者还是有一定区别的。</p>
<p><strong>常量池</strong><br>java原文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这个数据会很大以至于不能直接存到字节码里面，换另一种方式，可以存到常量池，这个字节码包含指向常量池的引用，我们在动态链接的时候就会把符号引用变成直接引用。</p>
<p>常量池通常分为字面量和符号引用，字面量比较接近于Java语言层面的常量的概念，比如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面的三类变量：</p>
<ul>
<li>1.类和接口的全限名称</li>
<li>2.字段的名称和描述符</li>
<li>3.方法的名称和描述符</li>
</ul>
<p>我先来贴一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerStrucTest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num1 = <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"测试方法内部结构"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodInnerStrucTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"count ="</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> cal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">39</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            var3.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在编译之后通过javap进行反编译，我只将反编译结果汇总的常量池贴出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #18.#55        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #17.#56        &#x2F;&#x2F; MethodInnerStrucTest.num:I</span><br><span class="line">   #3 &#x3D; Fieldref           #57.#58        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #4 &#x3D; Class              #59            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #5 &#x3D; Methodref          #4.#55         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 &#x3D; String             #60            &#x2F;&#x2F; count &#x3D;</span><br><span class="line">   #7 &#x3D; Methodref          #4.#61         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">   #8 &#x3D; Methodref          #4.#62         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">   #9 &#x3D; Methodref          #4.#63         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #10 &#x3D; Methodref          #64.#65        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #11 &#x3D; Class              #66            &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #12 &#x3D; Methodref          #11.#67        &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception.printStackTrace:()V</span><br><span class="line">  #13 &#x3D; Class              #68            &#x2F;&#x2F; java&#x2F;lang&#x2F;String</span><br><span class="line">  #14 &#x3D; Methodref          #17.#69        &#x2F;&#x2F; MethodInnerStrucTest.compareTo:(Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #15 &#x3D; String             #70            &#x2F;&#x2F; 测试方法内部结构</span><br><span class="line">  #16 &#x3D; Fieldref           #17.#71        &#x2F;&#x2F; MethodInnerStrucTest.str:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #17 &#x3D; Class              #72            &#x2F;&#x2F; MethodInnerStrucTest</span><br><span class="line">  #18 &#x3D; Class              #73            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">  #19 &#x3D; Class              #74            &#x2F;&#x2F; java&#x2F;lang&#x2F;Comparable</span><br><span class="line">  #20 &#x3D; Class              #75            &#x2F;&#x2F; java&#x2F;io&#x2F;Serializable</span><br><span class="line">  #21 &#x3D; Utf8               num</span><br><span class="line">  #22 &#x3D; Utf8               I</span><br><span class="line">  #23 &#x3D; Utf8               num1</span><br><span class="line">  #24 &#x3D; Utf8               ConstantValue</span><br><span class="line">  #25 &#x3D; Integer            23</span><br><span class="line">  #26 &#x3D; Utf8               str</span><br><span class="line">  #27 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #28 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #29 &#x3D; Utf8               ()V</span><br><span class="line">  #30 &#x3D; Utf8               Code</span><br><span class="line">  #31 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #32 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #33 &#x3D; Utf8               this</span><br><span class="line">  #34 &#x3D; Utf8               LMethodInnerStrucTest;</span><br><span class="line">  #35 &#x3D; Utf8               compareTo</span><br><span class="line">  #36 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #37 &#x3D; Utf8               o</span><br><span class="line">  #38 &#x3D; Utf8               test1</span><br><span class="line">  #39 &#x3D; Utf8               count</span><br><span class="line">  #40 &#x3D; Utf8               test2</span><br><span class="line">  #41 &#x3D; Utf8               (I)I</span><br><span class="line">  #42 &#x3D; Utf8               value</span><br><span class="line">  #43 &#x3D; Utf8               e</span><br><span class="line">  #44 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Exception;</span><br><span class="line">  #45 &#x3D; Utf8               cal</span><br><span class="line">  #46 &#x3D; Utf8               result</span><br><span class="line">  #47 &#x3D; Utf8               StackMapTable</span><br><span class="line">  #48 &#x3D; Class              #66            &#x2F;&#x2F; java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #49 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;Object;)I</span><br><span class="line">  #50 &#x3D; Utf8               &lt;clinit&gt;</span><br><span class="line">  #51 &#x3D; Utf8               Signature</span><br><span class="line">  #52 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;Comparable&lt;Ljava&#x2F;lang&#x2F;String;&gt;;Ljava&#x2F;io&#x2F;Serializable;</span><br><span class="line">  #53 &#x3D; Utf8               SourceFile</span><br><span class="line">  #54 &#x3D; Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #55 &#x3D; NameAndType        #28:#29        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #56 &#x3D; NameAndType        #21:#22        &#x2F;&#x2F; num:I</span><br><span class="line">  #57 &#x3D; Class              #76            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #58 &#x3D; NameAndType        #77:#78        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #59 &#x3D; Utf8               java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #60 &#x3D; Utf8               count &#x3D;</span><br><span class="line">  #61 &#x3D; NameAndType        #79:#80        &#x2F;&#x2F; append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #62 &#x3D; NameAndType        #79:#81        &#x2F;&#x2F; append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #63 &#x3D; NameAndType        #82:#83        &#x2F;&#x2F; toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #64 &#x3D; Class              #84            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #65 &#x3D; NameAndType        #85:#86        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #66 &#x3D; Utf8               java&#x2F;lang&#x2F;Exception</span><br><span class="line">  #67 &#x3D; NameAndType        #87:#29        &#x2F;&#x2F; printStackTrace:()V</span><br><span class="line">  #68 &#x3D; Utf8               java&#x2F;lang&#x2F;String</span><br><span class="line">  #69 &#x3D; NameAndType        #35:#36        &#x2F;&#x2F; compareTo:(Ljava&#x2F;lang&#x2F;String;)I</span><br><span class="line">  #70 &#x3D; Utf8               测试方法内部结构</span><br><span class="line">  #71 &#x3D; NameAndType        #26:#27        &#x2F;&#x2F; str:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #72 &#x3D; Utf8               MethodInnerStrucTest</span><br><span class="line">  #73 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #74 &#x3D; Utf8               java&#x2F;lang&#x2F;Comparable</span><br><span class="line">  #75 &#x3D; Utf8               java&#x2F;io&#x2F;Serializable</span><br><span class="line">  #76 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #77 &#x3D; Utf8               out</span><br><span class="line">  #78 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #79 &#x3D; Utf8               append</span><br><span class="line">  #80 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #81 &#x3D; Utf8               (I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #82 &#x3D; Utf8               toString</span><br><span class="line">  #83 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #84 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #85 &#x3D; Utf8               println</span><br><span class="line">  #86 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #87 &#x3D; Utf8               printStackTrace</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在常量池中看到         </p>
<p> #75 = Utf8               java/io/Serializable<br>通常表示符号引用<br>以及<br>  #25 = Integer            23<br>这样的自面量</p>
<p>这些符号引用通常是需要进行动态链接，在类创建的时候对这些符号引用进行解析，翻译到本地内存中，从而找到真正内存的入口地址。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。常量池表是Class文件的一部分，用于存放编译期生成的种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，都是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换成了真实地址。</p>
<p>运行时常量池，相对于class文件常量池的另一个重要特征是：具备动态性。<br>String：intern()<br>当创建类或者接口窦娥运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常。</p>
<h3 id="二-方法区的演进细节"><a href="#二-方法区的演进细节" class="headerlink" title="二. 方法区的演进细节"></a>二. 方法区的演进细节</h3><p>在jdk7及以前，习惯上将方法区称之为永久代，但是在1.7之后随着去永久代的落实，永久代的部分内容转移到堆中存储，在java1.8中，正式使用元空间代替了永久代。</p>
<p>本质上方法区和永久代也不是等价的，仅是堆hotspot而言，对如何实现方法区，不做统一要求，例如：BEA JRpckit/IBM J9中就不存在永久代。<br>现在来看，当年使用永久代。不是好的idea，导致Java程序更容易OOM（超过-XX：MaxPermSize上限）</p>
<p><img src="/images/pasted-50.png" alt="upload successful"></p>
<p>JDK8摒弃了永久代，使用元空间，这两者最大的区别在于<font color=#A52A2A size=4 >元空间不在虚拟机设置的内存中，而是使用本地内存。</font></p>
<h4 id="hotspot-方法区中的变化"><a href="#hotspot-方法区中的变化" class="headerlink" title="hotspot 方法区中的变化"></a>hotspot 方法区中的变化</h4><p><img src="/images/pasted-51.png" alt="upload successful"></p>
<p>这里面有一些问题需要注意，1. 永久代为什么要被元空间替换？ 2. 字符串常量池为什么会被转移到堆中 3. 静态变量为什么会被转移到堆中</p>
<h4 id="永久代被元空间替代"><a href="#永久代被元空间替代" class="headerlink" title="永久代被元空间替代"></a>永久代被元空间替代</h4><p>随着Java8的到来，Hotspot vm 中再也见不到永久代了，但是这并不意味着类的元数据信息也消失了，这些数据被移到一个与堆不相连的本地内存区域，这个区域叫做元空间。</p>
<p>由于类的元数据分配到本地内存中，元空间的最大可分配空间就是系统可用内存空间。在java虚拟机规范中说的是，为了使得hotspot和jrocket更好的融合，所以去除了方法区。这里解释其实有点含糊，我从我上课中记的笔记和我自己理解的进行一个解释：</p>
<ol>
<li><p>永久代设置空间大小是很难确定的<br>元空间默认的最大值为-1也就是整个本地内存，然而永久代的默认最大值是82m，这个是对于一个大工程尤其是使用多个动态代理框架来说是远远不够的，很容易就OOM，而设置永久代最大值需要结合多方面的元素比如JVM加载的class总数，常量池的大小，方法的大小等，如果过小就容易OOM，过大容易导致虚拟机内存紧张。而元空间并不在虚拟机中，而是使用的本地内存，因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
</li>
<li><p>对永久代调优是困难的<br>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
</li>
</ol>
<h4 id="字符串常量池和静态变量为什么调整"><a href="#字符串常量池和静态变量为什么调整" class="headerlink" title="字符串常量池和静态变量为什么调整"></a>字符串常量池和静态变量为什么调整</h4><p>字符串常量池在java1.7的时候被放入了堆中，因为永久代回收效率很低，在full gc的时候才会触发，而full GC是老年代空间不足、永久代空间不足才会触发的，这就导致了字符串常量池回收的效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆中能够及时回收。</p>
<p>首先放入堆中一个重要的好处就是当我们大量加载类或者使用String.intern的时候由于永久代或者元空间不存放字符串常量池，这使得在方法区中触发full GC就不会很频繁，并且应为字符串通常寿命较短在放在堆中垃圾回收的效率也高。</p>
<h3 id="二-方法区中的垃圾回收"><a href="#二-方法区中的垃圾回收" class="headerlink" title="二. 方法区中的垃圾回收"></a>二. 方法区中的垃圾回收</h3><p>《Java虚拟机规范》对方法区的垃圾回收是十分宽泛的。一般来说这个区域的回收效果比较难以令人满意，尤其是类型的加载，条件相当苛刻。但是这部分区域的回收有时又确实是有必要的。以前Sun公司Bug列表中，曾出现若干个严重的bug都是由于低版本的HotSpot虚拟机对此区域未完全回收而导致的内存泄漏。<br>方法区中的垃圾回收主要分为两个部分：<font color=#A52A2A size=4 >常量池中废弃的常量和不再使用的类型。</font></p>
<p>之前说过方法区中常量池主要有字面量和符号引用。HotSpot对常量池的回收策略是十分明确的，只要常量池中的常量没有任何地方引用，就可以被回收。</p>
<p>判定一个常量是否被“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>1.该类所有的实例都已经被回收了，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>2.加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI、JSP的重加载等，否则通常很难达成。</li>
<li>3.该类对应的Java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述的三个条件的无用类进行回收，这里仅仅说的是被允许，而不是和对象一样，没有引用就一定被回收。关于是够要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息。</p>
<p>在大量使用反射，动态代理，CGlab等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常需要JAVA虚拟机具备类型的卸载能力，以保证不会对方法区造成过大的压力。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后贴一张JVM的内存模型图，大家自行回忆一下我们学过的知识。</p>
<p><img src="/images/pasted-52.png" alt="upload successful"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener">尚硅谷2020最新版宋红康JVM教程持续更新中(java虚拟机详解，jvm从入门到精通)</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络(4)——DNS</title>
    <url>/2020/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4-%E2%80%94%E2%80%94DNS/</url>
    <content><![CDATA[<h3 id="一-DNS概念"><a href="#一-DNS概念" class="headerlink" title="一. DNS概念"></a>一. DNS概念</h3><p>通常我们对一个主机的标识是<font color=#A52A2A size=4 >域名</font>的形式，这中形式更易于记忆，如<a href="http://www.baidu.com等，而路由器并不知道www.baidu.com对应的是哪一台服务器，在他们眼里只有" target="_blank" rel="noopener">www.baidu.com等，而路由器并不知道www.baidu.com对应的是哪一台服务器，在他们眼里只有</a><font color=#A52A2A size=4 >IP</font>地址才是有效地址，这种定长的结构化表示也更易于解析和通信。为了解决域名和IP地址之间的映射关系，DNS站了出来。DNS(domain name system)是域名系统的缩写，他负责将我们看到的域名解析为ip地址。</p>
<h4 id="顶级域名、二级域名"><a href="#顶级域名、二级域名" class="headerlink" title="顶级域名、二级域名"></a>顶级域名、二级域名</h4><p>顶级域名(一级域名)如：.com、.net、.edu、.gov、.cn等。N级域名就是在N-1级域名前追加一级。比如.baidu.com就是一个二级域名，.siba.com.cn是一个三级域名。这里又一个误点，有很多人吧www也当作一个域名，这种理解其实是不恰当的，www其实是表示该主机所提供的服务为www服务，即万维网服务。具体大家可以参考<a href="https://www.zhihu.com/question/29998374/answer/477597889" target="_blank" rel="noopener">顶级域名 一级域名 二级域名 三级域名什么区别?</a>中的高赞回答。</p>
<h4 id="DNS层次关系"><a href="#DNS层次关系" class="headerlink" title="DNS层次关系"></a>DNS层次关系</h4><p><img src="/images/pasted-42.png" alt="upload successful"><br>如图，DNS层次关系通常是树状结构的，从上往下分别为根DNS服务器、顶级DNS服务器、权威DNS服务器。</p>
<ul>
<li>1.根DNS服务器：负责提供顶级域名服务器的IP地址，也就是根DNS服务器负责维护一张顶级DNS的映射表，一个顶级域名对应一个顶级DNS服务器的IP。</li>
<li>2.顶级DNS服务器：对于每个顶级域(如com、org、net、edu等)和国家顶级域都有顶级域服务器(TLD服务器)，TLD服务器负责提供权威DNS服务器的IP地址。</li>
<li>3.权威DNS服务器：在因特网上具有公共可访问的主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。</li>
</ul>
<p>除此之外还有一个本地DNS服务器，这个服务器通常与主机再同一个局域网当中。当主机发出DNS请求时，该请求被发往本地的DNS服务器，他起着代理的作用，并将该请求转发到DNS服务器层次结构中。他可以起到一个DNS缓存的作用，第一次DNS服务器在接收到返回的域名映射的IP地址，会将主机名和IP地址进行缓存，之后的一定时间内，如果客户端再次访问相同的主机时，本地DNS服务器会立刻返回对应的IP地址，减少其他DNS服务器的压力。</p>
<h3 id="二-DNS解析"><a href="#二-DNS解析" class="headerlink" title="二. DNS解析"></a>二. DNS解析</h3><p>当我们在浏览器输入一个URL的时候，通常第一步就是进行DNS解析，如<a href="http://www.baidu.com，会有很多步骤需要做。" target="_blank" rel="noopener">www.baidu.com，会有很多步骤需要做。</a></p>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<ol>
<li><p>查找浏览器缓存：因为浏览器一般会缓存DNS记录一段时间，不同浏览器的时间可能不一样，一般2-30分钟不等，浏览器去查找这些缓存，如果有缓存，直接返回IP，否则下一步。如chrome采用了预提DNS记录，在本地建立DNS缓存的方法，加快网站的连接速度。</p>
</li>
<li><p>查找系统缓存：浏览器缓存中找不到IP之后，浏览器会查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</p>
</li>
<li><p>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。</p>
</li>
<li><p>查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>
</li>
<li><p>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到顶级DNS服务器上去继续查询，并给出相应的顶级DNS服务器的地址。这种过程是迭代的过程。</p>
</li>
<li><p>本地DNS服务器继续向顶级DNS服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的权威DNS服务器的地址。</p>
</li>
<li><p>最后，本地DNS服务器向域名的权威DNS服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
</li>
</ol>
<h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>DNS进行解析的方式有两种，一种是迭代的方法，也就是我们上面用到的，一种是递归的方法。</p>
<p><strong>递归解析</strong><br><img src="/images/pasted-44.png" alt="upload successful"><br>本地DNS服务器自己负责向其他DNS服务器进行查询，一般是先向根DNS服务器查询，再由根DNS服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>
<p><strong>迭代解析</strong><br><img src="/images/pasted-45.png" alt="upload successful"><br>当本地DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。本地DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。</p>
<p>实际使用中，主机向本地dns服务器的查询是一种递归查询方式，本地dns服务器向其他dns服务器查询使用的迭代方式。</p>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p>
<p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>
<p>解决方法：<br>1.加强本地计算机病毒检查，开启防火墙等，防止恶意软件，木马病毒感染计算机<br>2.改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器<br>3.企业的话可以准备两个以上的域名，一旦一个域名挂掉，还可以使用另一个<br>4.用HTTP DNS 代替 Local DNS</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://bbs.huaweicloud.com/blogs/109378" target="_blank" rel="noopener">浅谈DNS缓存机制–浏览器和OS篇</a><br><a href="https://juejin.im/post/5df5d72be51d45584006ddfe" target="_blank" rel="noopener">浏览器输入URL后发生了啥</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络(3)——HTTP</title>
    <url>/2020/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E2%80%94%E2%80%94HTTP/</url>
    <content><![CDATA[<h3 id="一-HTTP简介"><a href="#一-HTTP简介" class="headerlink" title="一. HTTP简介"></a>一. HTTP简介</h3><blockquote>
<p>今天看了一些http协议的一些相关的概念，准备在博客中记录一下。<br>HTTP是客户端和服务端用于通信的协议，可以用来传输文本、图片、文件。他是基于TCP连接，所以说HTTP协议是一个可靠的协议，当HTTP客户端发起一个与服务端的TCP连接，一旦连接建立起来，该浏览器和服务器进程就可以通过套接字接口访问TCP。</p>
</blockquote>
<h3 id="二-HTTP特性"><a href="#二-HTTP特性" class="headerlink" title="二. HTTP特性"></a>二. HTTP特性</h3><h4 id="1-HTTP的无状态"><a href="#1-HTTP的无状态" class="headerlink" title="1. HTTP的无状态"></a>1. HTTP的无状态</h4><p>HTTP是一种无状态的协议，我们如何去理解无状态协议呢。当浏览器向服务端连续发送相同的请求时，服务器不会因为两次请求的相同而返回不同的响应，而是从新去发送请求的对象，就像服务器完全忘记之前做过的事情一样，换一句话说就是每一次请求都是完全独立的。因为HTTP服务器不会保存关于客户的任何相关信息，所以说HTTP是一个无状态的。</p>
<p>那如果我们需要使用HTTP协议去维持一个有状态的场景应该怎么办呢。比如说我们登陆网站，我们会对服务端发送一个登陆请求，登陆上以后我们想浏览网站，就会对服务端发送其他请求，我们想要服务端记住我们已经登陆的状态，这种情况下我们应该如何去处理问题呢？为了帮助HTTP变得有状态，我们通常使用Session和Cookie，我这里先卖一个关子，后面为大家详细介绍。</p>
<h4 id="2-HTTP的长连接和短连接"><a href="#2-HTTP的长连接和短连接" class="headerlink" title="2. HTTP的长连接和短连接"></a>2. HTTP的长连接和短连接</h4><p>HTTP的短连接就是，当客户端向服务端每发送一次请求是就要建立一次TCP连接然后传输数据然后立刻关闭连接，这样当客户端向服务端请求的web页面含有多个对象时如图片、视频等，每多一个对象，客户端就需要重新和服务端建立一次连接，这样无疑会增加网页加载的时间。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<br>Connection:keep-alive</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>我们都说HTTP长连接和短连接本质上是TCP的长连接和短连接，应为HTTP是应用层上的协议，它的底层是基于TCP，应为TCP协议支持长连接，能够保持TCP在请求结束后不立刻关闭，所以说HTTP支持长连接，如果TCP协议在请求结束后立刻关闭，我们说这样的HTTP是短连接的。</p>
<p>当我们请求的一个网页含有大量的图片、CSS、JS等静态资源，长连接能够帮助我们只建立一个TCP通道就可以完成全部的请求，这就省下了大量的资源消耗。</p>
<h3 id="三-HTTP格式"><a href="#三-HTTP格式" class="headerlink" title="三. HTTP格式"></a>三. HTTP格式</h3><p>应为HTTP不仅用于发送请求服务端，还用于响应客户端。所以HTTP包含了请求报文格式和响应报文格式。</p>
<h4 id="1-请求报文格式"><a href="#1-请求报文格式" class="headerlink" title="1. 请求报文格式"></a>1. 请求报文格式</h4><p><img src="/images/pasted-30.png" alt="upload successful"><br>请求报文包括，请求行、请求头部、请求体。<br><strong>请求行</strong></p>
<ul>
<li><p>请求方法：有GET、POST、PUT、DELET。GET请求参数可以放在URL后面，而POST请求的数据参数只能放在请求数据里面，和GET请求相比POST请求更安全一些，并且应为POST请求的参数是放在请求数据内，POST可以传输的数据也更多一些。PUT和DELET使用的更少一些，以我的使用经验来说，这些往往适合REST风格配合使用。</p>
</li>
<li><p>URL：是指请求的资源</p>
</li>
<li><p>协议版本：指HTTP协议的版本，如HTTP/1.1</p>
</li>
</ul>
<p><strong>请求头部</strong><br>请求头部由头部字段名：值的格式构成，看起来像JSON格式，我介绍一些比较常用的。</p>
<ul>
<li><p>user-agent: 这的是用户使用浏览器版本。例如：user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36。这个是chrome的引擎。</p>
</li>
<li><p>Cookie：用于在客户端存储少量的信息，通常用于实现session功能。</p>
</li>
<li><p>Host：请求的资源在哪个主机的端口上。</p>
</li>
</ul>
<p><strong>请求数据</strong><br>请求数据又叫请求体，使用是用于传输html表单中的信息。通常来说使用POST方法会将参数放到请求体中，而使用GET方法一般不会放在请求体中。</p>
<h4 id="2-响应报文格式"><a href="#2-响应报文格式" class="headerlink" title="2. 响应报文格式"></a>2. 响应报文格式</h4><p><img src="/images/pasted-32.png" alt="upload successful"><br>响应报文协议是当服务端进行处理返回给客户端的信息，这里面同样包含了3个部分，响应行、响应头、响应正文。<br><strong>响应行</strong><br>由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔。</p>
<p>状态代码为3位数字，200~299的状态码表示成功，300~399的状态码指资源重定向，400~499的状态码指客户端请求出错，500~599的状态码指服务端出错（HTTP/1.1向协议中引入了信息性状态码，范围为100~199）</p>
<p>这里举出一些常见的：<br><img src="/images/pasted-33.png" alt="upload successful"></p>
<p><strong>响应头</strong><br>与请求头部类似，为响应报文添加了一些附加信息<br><img src="/images/pasted-34.png" alt="upload successful"></p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>我们前面提到了http是无状态的。这简化了服务器的设计，并且可以允许程序员去开发可以同时处理数以千计的TCP连接的高新能Web服务器。然而一个Web站点经常希望能够识别用户。为此，HTTP使用了cookie。cookie在HTTP应用中有四个部分：</p>
<ul>
<li><ol>
<li>http请求头部包含了cookie字段</li>
</ol>
</li>
<li><ol start="2">
<li>http响应报文包含了Set-Cookie字段</li>
</ol>
</li>
<li><ol start="3">
<li>服务端数据库会保存cookie的相关信息。</li>
</ol>
</li>
<li><ol start="4">
<li>客户端会保存cookie信息的文件。</li>
</ol>
</li>
</ul>
<p>我们举一个例子，假设张三晚上想上淘宝，当他第一次上淘宝时，我们假定他以前访问过淘宝，当请求报文到达淘宝的时候，淘宝的服务器会生成一个唯一的识别码，并以此作为索引在他的后端数据库产生一个表项，接下来淘宝的服务器会用一个包含了set-cookie首部的http响应报文对于张三的浏览器进行响应，其中set-cookie就含有该识别码。可能是</p>
<ul>
<li>Set-cookie:1678<br>当张三的浏览器收到了该HTTP响应报文时，他会看到set-cookie：首部。该浏览器在他管理的cookie文件中会添加一行，该行包含服务器的主机名和在set-cookie：首部的识别码。当张三继续浏览淘宝时，其浏览器就会查询该cookie文件并抽取他对这个网站的识别码，并放到http请求报的识别码的cookie首部行中。之后每一次发往淘宝的cookie的请求报文中就包含了一下首部行：</li>
<li>cookie:1678<br>在这样的方式下，淘宝就可以跟踪张三的浏览记录，并为张三提供购物车服务，即淘宝可以维护张三希望购买的物品列表，这样张三在结束回话时可以一起为他们支付。</li>
</ul>
<p>如果张三再次访问该网站的时候，比如说是一个星期以后，她的浏览器会在其请求报文中继续放入首部行cookie：1678.淘宝将根据张三过去访问过的页面向她推荐产品，如果张三在淘宝网注册过，可以将邮件地址、银行卡相关联，这就可以解释淘宝等购物网站的点击购物功能，即在点击购买的时候不需要重新提供信用卡和姓名。</p>
<h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>Web缓存器也叫做代理服务器，它能够代表初始的服务器来满足http请求的网络实体，并在存储空见保存最近请求过的对象的副本。<br>举一个例子，如果有一个浏览器想访问淘宝。</p>
<ul>
<li><ol>
<li>浏览器首先会向web缓存器发送http请求。</li>
</ol>
</li>
<li><ol start="2">
<li>缓存服务器会查询存储空间中是否含有请求对象的副本，如果含有的话，立刻返回副本数据。</li>
</ol>
</li>
<li><ol start="3">
<li>如果web缓存器中没有该对象，他就打开一个与该对象的初始服务器的TCP连接，web缓存器则向淘宝网发送http请求，在收到请求后，淘宝的服务器会返回一个响应报文。</li>
</ol>
</li>
<li><ol start="4">
<li>当web缓存起接收到该对象是，他在本地存储空间会存储一份副本，并向客户端浏览器发送该副本。</li>
</ol>
</li>
</ul>
<p>这样以后在去访问该对象时，就可以快速返回。但是这会有一个问题，如果代理服务器备份的副本时间过长，对象已经被修改了，这样web缓存器返回回来的对象就是错误的。<br>我们使用条件GET可以解决这个问题，条件GET是指在请求报文中，我们使用GET方法，并且在请求头中包含了“If-Modified-Since”字段，这是由web缓存起发送的，缓存器在备份副本的时候会记录修改的时间，当浏览器再次请求相同的对象时，web缓存器会先向服务端发送一个包含If-Modified-Since的GET请求，如果没有被修改则返回一个304响应报文。这样虽然会影响一些效率，但是增加了安全性和可靠性。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/a19881029/article/details/14002273" target="_blank" rel="noopener">HTTP请求、响应报文格式</a><br><a href="https://www.cnblogs.com/williamjie/p/9099940.html" target="_blank" rel="noopener">浅谈HTTP中GET、POST用法以及它们的区别
</a><br><a href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.56.1b7127efE3BbeC&id=574793583993&user_id=101450072&cat_id=2&is_b=1&rn=6f69597db6ce41773f733a2e3368654d" target="_blank" rel="noopener">计算机网络 自顶向下方法</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式笔记(4)——观察者模式(转)</title>
    <url>/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-4-%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一-观察者模式模式简介"><a href="#一-观察者模式模式简介" class="headerlink" title="一. 观察者模式模式简介"></a>一. 观察者模式模式简介</h3><p>文章转发自<a href="https://blog.csdn.net/itachi85/article/details/50773358" target="_blank" rel="noopener">设计模式（五）观察者模式</a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<h4 id="观察者模式结构图"><a href="#观察者模式结构图" class="headerlink" title="观察者模式结构图"></a>观察者模式结构图</h4><p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p>在观察者模式中有如下角色：</p>
<ul>
<li><p>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</p>
</li>
<li><p>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</p>
</li>
<li><p>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</p>
</li>
<li><p>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p>
</li>
</ul>
<h3 id="二-观察者模式简单实现"><a href="#二-观察者模式简单实现" class="headerlink" title="二. 观察者模式简单实现"></a>二. 观察者模式简单实现</h3><p>观察者模式这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。好了我们来看看用代码如何实现：</p>
<p><strong>抽象观察者（Observer）</strong><br>微信用户是观察者，里面实现了更新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>具体观察者（ConcrereObserver）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"-"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>抽象被观察者（Subject）</strong><br>抽象主题，提供了attach、detach、notify三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>具体被观察者（ConcreteSubject）</strong><br>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>客户端调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> SubscriptionSubject();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">"杨影枫"</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">"月眉儿"</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">"紫轩"</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">"刘望舒的专栏更新了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure>

<h3 id="三-使用观察者模式的场景和优缺点"><a href="#三-使用观察者模式的场景和优缺点" class="headerlink" title="三. 使用观察者模式的场景和优缺点"></a>三. 使用观察者模式的场景和优缺点</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络(2)——网络编程BIO、NIO</title>
    <url>/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BBIO%E3%80%81NIO%E3%80%81AIO/</url>
    <content><![CDATA[<h3 id="计算机网络-2-——网络编程BIO、NIO"><a href="#计算机网络-2-——网络编程BIO、NIO" class="headerlink" title="计算机网络(2)——网络编程BIO、NIO"></a>计算机网络(2)——网络编程BIO、NIO</h3><blockquote>
<p>本来在学习nginx，想写一些nginx的blog，但是在看一写blog的时候，看到了io多路复用，epoll等概念，确认过眼神，是没学过的概念，于是由转而看起了网络编程多线程相关的一些知识，也是学到了很多新的知识。</p>
</blockquote>
<h4 id="一-同步、异步、阻塞、非阻塞"><a href="#一-同步、异步、阻塞、非阻塞" class="headerlink" title="一. 同步、异步、阻塞、非阻塞"></a>一. 同步、异步、阻塞、非阻塞</h4><p>同步、异步是两种通信机制，同步是指在调用函数的时候，必须要有返回结果才能够继续往下执行；异步则是指，调用在发出的时候，调用者不会立刻得到结果，而是在调用发出之后，被调用者通过状态、通知来通知调用者，或者通过回调函数处理这个调用。<br><img src="/images/pasted-25.png" alt="upload successful"><br>上图比较清晰的给我们解释了什么事同步IO，什么是异步IO，同步IO是当系统调用发生时，内核会将程序挂起，CPU会从用户空间切换到内核空间进行数据交换，完成系统调用时，CPU返回用户空间并返回结果，进程由挂起状态转换为就绪状态，准备执行下面的命令。而异步IO是当系统调用发生时，系统会立即给程序发生一个结果，好让程序继续往下执行，当系统调用结束时，系统通通知调用进程。（设置一个用户空间特殊的变量值或者触发一个signal或者产生一个软中断 或者调用应用程序的回调函数）</p>
<p>而阻塞和非阻塞是种状态，它们关注的是程序在等待结果时的状态，阻塞是指程序在调用结果返回直线，当前线程会被挂起，只有在得到结果之后才能返回。这种被挂起的状态被称为阻塞。非阻塞是指线程在结果返回之前不会被挂起，该调用会执行其他的事情。</p>
<p>同步IO可以分为阻塞IO和非阻塞IO，我们之后谈论的BIO就是阻塞IO，NIO是非阻塞IO，而aio就是异步io。</p>
<h4 id="二-BIO模型"><a href="#二-BIO模型" class="headerlink" title="二. BIO模型"></a>二. BIO模型</h4><p>BIO又叫做blocking IO，阻塞模型，下面我们来说BIO流程，注意下面所说的都是针对多线程的。</p>
<p><img src="/images/pasted-26.png" alt="upload successful"><br>采用BIO的服务端会用一个socket去监听窗口，当有客户端连接进来时，socket会创建一个新的线程用于和客户端进行交互，通过输出流返回应答给客户端，线程销毁，这是典型的 请求——应答 模型。<br>下面上代码：<br><em>BIOServer</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServerSocket server;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        start(PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(server != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动， 端口号:"</span> + port);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> BIOServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(server != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"服务器关闭"</span>);</span><br><span class="line">                server.close();</span><br><span class="line">                server = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>BIO服务端交互代码</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BIOServerHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            String expression;</span><br><span class="line">            String result;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//通过BufferedReader读取一行</span></span><br><span class="line">                <span class="comment">//如果已经读到输入流尾部，返回null,退出循环</span></span><br><span class="line">                <span class="comment">//如果得到非空值，就尝试计算结果并返回</span></span><br><span class="line">                <span class="keyword">if</span>((expression = in.readLine()) ==  <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(<span class="string">"服务器收到消息："</span> + expression);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = <span class="string">"to do！"</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    result = <span class="string">"计算错误"</span> + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(result);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>BIOClient</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String IP = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String expression)</span></span>&#123;</span><br><span class="line">        send(PORT, expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> port, String expression)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送消息为："</span> + expression);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(IP, PORT);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            out.println(expression);</span><br><span class="line">            System.out.println(<span class="string">"结果为:"</span>+ in.readLine());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>测试代码</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BIOServer.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">char</span> operators[] = &#123;<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>&#125;;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    String expression = random.nextInt(<span class="number">10</span>)+<span class="string">""</span>+operators[random.nextInt(<span class="number">4</span>)]+(random.nextInt(<span class="number">10</span>)+<span class="number">1</span>);</span><br><span class="line">                    BIOClient.send(expression);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BIO的只适用与小并发量且是一问一答的程序，因为每有一个客户端连接进来，服务端就会创建一个新的线程用于对接，线程也会占用内存资源，并且创建线程需要进行系统调用，当线程数量快速膨胀后，cpu需要不断切换线程，这样上下文切换将会占用cpu大量的时间。最重要的缺点是accept是阻塞的，这是无法解决根本问题的，而NIO作为非阻塞模型，就可以很好解决这个问题。</p>
<h4 id="三-NIO模型"><a href="#三-NIO模型" class="headerlink" title="三. NIO模型"></a>三. NIO模型</h4><p>Nio官方叫法new io，我们习惯称之为no-block io应为非阻塞是nio的最大的特点。对于NIO，如果TCP RecvBUffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则返回0，永远不会阻塞。在NIO中用户最关心的是，“我可以读了”。本质上来说，NIO模型中，socket主要的读写、注册、接收函数，在等待就绪阶段是非堵塞的，真正的IO操作是同步阻塞的。<br>我们回忆BIO模型，之所以需要多线程，是因为在进行IO操作的时候，一是没有办法知道到底能不能写，能不能读，只能等待，即使通过各种估算，算出来的操作系统没有能力进行读写，也没有办法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断，所以除了多开线程另其炉灶，没有好的办法利用CPU。NIO的读写函数可以立即返回，这就给我们不开线程，这就给我们不开线程利用CPU的最好机会，如果一个连接不能读写，我们可以吧这件事记下来，通常的方式是在selector上注册标记位，然后切换到其他就绪的连接继续进行读写。</p>
<p>NIO最重要的三个基本概念是channel、buffer、selector。</p>
<h5 id="1-channel"><a href="#1-channel" class="headerlink" title="1.channel"></a>1.channel</h5><p>channel 我们通过翻译可以看出，它是一个通道，可以与硬件如网卡、硬盘进行连接，当通道被被打开时，我们可以向通道中读写数据。和流的概念类似但是通道是双向的，而流只具有单向性，并且通道可以支持多线程的读写，比较重要的的一些通道如FileChannel、ServerSocketChannel、SocketChannel都是现在比较常用的类，再多线程中发挥着重要作用，由于我们这只将网络编程，所以我下面重点介绍ServerSocketChannel、SocketChannel。</p>
<blockquote>
<p><em>ServerSocketChannel</em></p>
</blockquote>
<p>ServerSocketChannel 是用于TCP服务端的通道，他的作用和标准IO中的ServerSocket类似，可以绑定端口进行监听。和ServerSocket相比，ServerSocketChannel最大的优势是可以设置为非阻塞的状态，当没有客户端连接进来时，ServerSocketChannel可以立刻返回null，如果有客户端连接时，就会和ServerSocket一样返回一个Socket，除此之外ServerSocketChannel是多线程安全的，支持多线程并发。</p>
<blockquote>
<p><em>SocketChannel</em></p>
</blockquote>
<p>SocketChannel 是用于TCP客户端的通道，它同样可以设置非阻塞模式对服务端进行连接，以及对通道内的数据进行读写。SocketChannel还有一个特点就是支持异步关闭，如果SocketChannel在一个线程上read阻塞，另一个线程对该SocketChannel调用shutdownInput，则读阻塞的线程将返回-1表示没有读取任何数据；如果SocketChannel在一个线程上write阻塞，另一个线程对该SocketChannel调用shutdownOutput，则写阻塞的线程将抛出AsynchronousCloseException。</p>
<h5 id="2-buffer"><a href="#2-buffer" class="headerlink" title="2.buffer"></a>2.buffer</h5><p>Buffer通常与Channel进行交互，数据从通道读入缓冲区，或者从缓冲区写入通道中，缓冲区本质上是一个可以写入数据的数组，之后可以读取数据，Buffer对象包装了此内存块，可以更轻松的使用内存块。</p>
<p>使用buffer时通常遵循以下几个步骤：</p>
<ol>
<li>将数据写入缓冲区</li>
<li>调用buffer.flip()反转读写模式</li>
<li>从缓冲区读取数据</li>
<li>调用buffer.clear()或者buffer.compact()清除缓冲区的内容。</li>
</ol>
<p>将数据写入Buffer 时，Buffer 会跟踪写入的数据量。 当需要读取数据时，就使用 flip() 方法将缓冲区从写入模式切换到读取模式。 在读取模式下，缓冲区允许读取写入缓冲区的所有数据。</p>
<p>读完所有数据之后，就需要清除缓冲区，以便再次写入。 可以通过两种方式执行此操作：通过调用 clear() 或调用 compact() 。区别在于 clear() 是方法清除整个缓冲区，而 compact() 方法仅清除已读取的数据，未读数据都会移动到缓冲区的开头，新数据将在未读数据之后写入缓冲区。</p>
<p>buffer有一些基本概念：</p>
<ol>
<li>capacity：指的时缓冲区的容量，是他所包含的元素的数量，不能为负并且不能够更改。</li>
<li>position：缓冲去的位置， 是下一个要读取或者要写入的元素的索引。不能为负，并且不能够大于limit</li>
<li>limit：缓冲区的限制，缓冲区的限制不能为负，并且不能够大于capacity</li>
</ol>
<p>另外还有标记 mark ，<br>标记、位置、限制和容量值遵守以下不变式：<br>0 &lt;= mark&lt;= position &lt;= limit&lt;= capacity</p>
<p>position和limit的含义取决于Buffer是处于读取还是写入模式。无论缓冲模式如何，capacity总是一样表示容量。</p>
<p>以下是写入和读取模式下的容量，位置和限制的说明：<br><img src="/images/pasted-27.png" alt="upload successful"></p>
<p><strong>capacity</strong></p>
<blockquote>
<p>作为存储器块，缓冲区具有一定的固定大小，也称为“容量”。 只能将 capacity 多的 byte，long，char 等写入缓冲区。 缓冲区已满后，需要清空它（读取数据或清除它），然后才能将更多数据写入。</p>
</blockquote>
<p><strong>position</strong></p>
<blockquote>
<p>将数据写入缓冲区时，可以在某个位置执行操作。 position 初始值为 0 ，当一个 byte，long，char 等已写入缓冲区时，position 被移动，指向缓冲区中的下一个单元以插入数据。 position 最大值为 capacity -1</p>
</blockquote>
<blockquote>
<p>从缓冲区读取数据时，也可以从给定位置开始读取数据。 当缓冲区从写入模式切换到读取模式时，position 将重置为 0 。当从缓冲区读取数据时，将从 position 位置开始读取数据，读取后会将 position 移动到下一个要读取的位置。</p>
</blockquote>
<p><strong>limit</strong></p>
<blockquote>
<p>在写入模式下，Buffer 的 limit 是可以写入缓冲区的数据量的限制，此时 limit=capacity。</p>
</blockquote>
<blockquote>
<p>将缓冲区切换为读取模式时，limit 表示最多能读到多少数据。 因此，当将 Buffer 切换到读取模式时，limit被设置为之前写入模式的写入位置（position ），换句话说，你能读到之前写入的所有数据（例如之前写写入了 6 个字节，此时 position=6 ，然后切换到读取模式，limit 代表最多能读取的字节数，因此 limit 也等于 6）。</p>
</blockquote>
<p><strong>分配缓冲区</strong><br>buffer 在一开始需要使用allocate来分配缓冲区的大小，缓冲区的大小决定了capacity的大小。例子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>); <span class="comment">//创建容量为48字节的缓冲区</span></span><br></pre></td></tr></table></figure>

<p><strong>将数据写入缓冲区</strong><br>可以通过两种方式将数据写入 Buffer：</p>
<ol>
<li>将数据从通道写入缓冲区</li>
<li>通过缓冲区的 put() 方法,自己将数据写入缓冲区。<br>这是一个示例，显示了 Channel 如何将数据写入 Buffer：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> data = fileChannel.read(buffer); <span class="comment">// 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数</span></span><br><span class="line">buffer.put(<span class="number">127</span>); <span class="comment">// 此处的 127 是 byte 类型</span></span><br></pre></td></tr></table></figure>

<p><em>flip() 切换缓冲区的读写模式</em><br>flip() 方法将 Buffer 从写入模式切换到读取模式。 调用 flip() 会将 position 设置回 0，并将 limit 的值设置为切换之前的 position 值。换句话说，limit 表示之前写进了多少个 byte、char 等 —— 现在能读取多少个 byte、char 等。</p>
<p><strong>从缓冲区读取数据</strong><br>有两种方法可以从 Buffer 中读取数据：</p>
<ol>
<li>将数据从缓冲区读入通道。</li>
<li>使用 get() 方法之一，自己从缓冲区读取数据。<br>以下是将缓冲区中的数据读入通道的示例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = fileChannel.write(buffer);</span><br><span class="line"><span class="keyword">byte</span> aByte = buffer.get();    </span><br></pre></td></tr></table></figure>

<p>和 put() 方法一样，get() 方法也有许多其他版本，允许以多种不同方式从 Buffer 中读取数据。有关更多详细信息，请参阅JavaDoc以获取具体的缓冲区实现。</p>
<p><strong>rewind() 倒带</strong><br>Buffer对象的 rewind() 方法将 position 设置回 0，因此可以重读缓冲区中的所有数据， limit 则保持不变。</p>
<p><strong>clear() 和 compact()</strong><br>如果调用 clear() ,则将 position 设置回 0 ，并将 limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。 但是 Buffer 中的实际存放的数据并未清除。</p>
<p>如果在调用 clear() 时缓冲区中有任何未读数据，数据将被“遗忘”，这意味着不再有任何标记告诉读取了哪些数据，还没有读取哪些数据。</p>
<p>如果缓冲区中仍有未读数据，并且想稍后读取它，但需要先写入一些数据，这时候应该调用 compact() ，它会将所有未读数据复制到 Buffer 的开头，然后它将 position 设置在最后一个未读元素之后。 limit 属性仍设置为 capacity ，就像 clear() 一样。 现在缓冲区已准备好写入，并且不会覆盖未读数据。</p>
<p><strong>mark() 和 reset()</strong><br>以通过调用 Buffer 对象的 mark() 方法在 Buffer 中标记给定位置。 然后，可以通过调用 Buffer.reset() 方法将位置重置回标记位置，就像在标准 IO 中一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">// 调用 buffer.get() 等方法读取数据...</span></span><br><span class="line"></span><br><span class="line">buffer.reset();  <span class="comment">// 设置 position 回到 mark 位置。    </span></span><br></pre></td></tr></table></figure>

<p><strong>使用buffer的一些好处</strong></p>
<p>当我们使用buffer和channel共同进行数据传输的时候，channel解决了阻塞的问题，那么buffer解决了什么问题？下面我们看一下buffer和channel的流程图</p>
<p><img src="/images/pasted-28.png" alt="upload successful"><br>乍一看内核空间和用户空间进行交互的时候，还需要现将数据放入到buffer然后在通过read取出来不是多此一举吗？其实不然，我们设想以下下面的情况，<br>ByteBuffer buffer = ByteBuffer.allocate(1024 * 4);<br>……<br>channel.read(buffer);<br>……<br>while(true){<br>byte[] buf = new byte[32];<br>buffer.read(buf);<br>//handle<br>}<br>如果有1024<em>4 个byte需要读取，若我们使用字节流读取的话就需要进行1024</em>4/32次IO操作，若我们提前讲数据放入buffer，我们就只需要一次IO操作，其他的操作都是在内存中进行，效率就会高很多。</p>
<h5 id="3-selector"><a href="#3-selector" class="headerlink" title="3.selector"></a>3.selector</h5><p>Selector是NIO中的一个组件，它负责监控和管理多个Channel从而管理多个网络连接。并可以使用轮询的方式确定那些通道可以读写。通道必须处于非阻塞的模式才能够和选择器一起使用，这意味着无法将FileChannel与Selector一起使用，因为FileChannel无法切换到非阻塞模式。套接字通道则支持。</p>
<p>通常selector通过register()的方法来管理通道，他可以监听四种不同的事件，</p>
<ul>
<li>Connect 连接</li>
<li>Accept 接收</li>
<li>Read 读</li>
<li>Write 写</li>
</ul>
<p>一个“发起事件”的通道也被称为“已就绪”事件。 因此，已成功连接到另一台服务器的通道是“连接就绪”。 接受传入连接的服务器套接字通道是“接收就绪”。 准备好要读取的数据的通道“读就绪”。 准备好写入数据的通道称为“写就绪”。</p>
<p>下面结合一个具体的例子我们来操作NIO<br><strong>NIOServer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NIOServerHandle serverhandle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        start(PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serverhandle!=<span class="keyword">null</span>)</span><br><span class="line">            serverhandle.stop();</span><br><span class="line">        serverhandle = <span class="keyword">new</span> NIOServerHandle(port);</span><br><span class="line">        <span class="keyword">new</span> Thread(serverhandle,<span class="string">"Server"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>NIOServerHandler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServerHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServerHandle</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port),<span class="number">1024</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动， 端口号"</span>+ port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;started = <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (started)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        hanleInput(key);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(key != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span>(key.channel() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(selector != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanleInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = ssc.accept();</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">int</span> readBytes = sc.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(readBytes &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                    buffer.get(bytes);</span><br><span class="line">                    String expression = <span class="keyword">new</span> String(bytes,<span class="string">"UTF-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"服务器收到消息："</span> + expression);</span><br><span class="line">                    String result = <span class="string">"to do"</span>;</span><br><span class="line">                    doWrite(sc, result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span>(readBytes&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel channel, String response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = response.getBytes();</span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        channel.write(writeBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>NIOClient</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String HOST = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NIOClientHandle clientHandle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        start(HOST,PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(clientHandle != <span class="keyword">null</span>)</span><br><span class="line">            clientHandle.stop();</span><br><span class="line">        clientHandle = <span class="keyword">new</span> NIOClientHandle(host,port);</span><br><span class="line">        <span class="keyword">new</span> Thread(clientHandle,<span class="string">"Server"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.equals(<span class="string">"q"</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        clientHandle.sendMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>NIOClientHandle</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedChannelException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClientHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOClientHandle</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//打开监听通道</span></span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            <span class="comment">//如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//开启非阻塞模式</span></span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        started = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConnect();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (started)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select(<span class="number">1000</span>);</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                SelectionKey key = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                    key = it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        handleInput(key);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(key != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            <span class="keyword">if</span>(key.channel() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                                key.channel().close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(selector != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(host,port)));</span><br><span class="line">        <span class="keyword">else</span> socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        doWrite(socketChannel, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SocketChannel channel,String request)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//将消息编码为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = request.getBytes();</span><br><span class="line">        <span class="comment">//根据数组容量创建ByteBuffer</span></span><br><span class="line">        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">        <span class="comment">//将字节数组复制到缓冲区</span></span><br><span class="line">        writeBuffer.put(bytes);</span><br><span class="line">        <span class="comment">//flip操作</span></span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        <span class="comment">//发送缓冲区的字节数组</span></span><br><span class="line">        channel.write(writeBuffer);</span><br><span class="line">        <span class="comment">//****此处不含处理“写半包”的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.isValid())&#123;</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">                <span class="keyword">if</span>(sc.finishConnect());</span><br><span class="line">                <span class="keyword">else</span> System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读消息</span></span><br><span class="line">            <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                <span class="comment">//创建ByteBuffer，并开辟一个1M的缓冲区</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//读取请求码流，返回读取到的字节数</span></span><br><span class="line">                <span class="keyword">int</span> readBytes = sc.read(buffer);</span><br><span class="line">                <span class="comment">//读取到字节，对字节进行编解码</span></span><br><span class="line">                <span class="keyword">if</span>(readBytes&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//将缓冲区当前的limit设置为position=0，用于后续对缓冲区的读取操作</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="comment">//根据缓冲区可读字节数创建字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                    <span class="comment">//将缓冲区可读字节数组复制到新建的数组中</span></span><br><span class="line">                    buffer.get(bytes);</span><br><span class="line">                    String result = <span class="keyword">new</span> String(bytes,<span class="string">"UTF-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"客户端收到消息："</span> + result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有读取到字节 忽略</span></span><br><span class="line"><span class="comment">//				else if(readBytes==0);</span></span><br><span class="line">                <span class="comment">//链路已经关闭，释放资源</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(readBytes&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//运行服务器</span></span><br><span class="line">        NioServer.start();</span><br><span class="line">        <span class="comment">//避免客户端先于服务器启动前执行代码</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//运行客户端</span></span><br><span class="line"></span><br><span class="line">        NIOClient.start();</span><br><span class="line">        <span class="keyword">while</span>(NIOClient.sendMsg(<span class="keyword">new</span> Scanner(System.in).nextLine()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a><br><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码）</a><br><a href="https://www.jianshu.com/p/49754f69822c" target="_blank" rel="noopener">BIO/NIO底层原理分析</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2" target="_blank" rel="noopener">清华大牛权威讲解nio,epoll,多路复用，更好的理解redis-netty-Kafka等热门技术</a><br><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a><br><a href="https://www.cnblogs.com/lxyit/p/9209407.html" target="_blank" rel="noopener">SocketChannel简述</a><br><a href="https://www.cnblogs.com/czwbig/p/10035631.html" target="_blank" rel="noopener">Java NIO 学习笔记（一）—-概述，Channel/Buffer</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络(1)——socket编程</title>
    <url>/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E2%80%94%E2%80%94socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>最近做项目，需要了解一些socket编程的相关知识，因为本身在大学的时候也接触过socket编程，但是时间已经很久了，并且当时学的不够用心，今天下午看了一些博客，对socket有了一些新的认识，在这里记录一下我学到的一些知识。</p>
<h4 id="一-什么是socket"><a href="#一-什么是socket" class="headerlink" title="一.什么是socket"></a>一.什么是socket</h4><p>什么socket，这里我们要先从osi模型和TCP/IP模型开始讲起，OSI一共包含了7层，其中应用层、表示层和会话层是面向用户的，程序员可以在此基础上进行开发，如http、ftp、SMTP(邮件)等协议就是基于应用层建立的，下面的四层协议是由系统内核封装，对用户不可见的。<br><img src="/images/pasted-19.png" alt="upload successful"></p>
<p>OSI模型表达的过于复杂，为了简化模型，人们又提出了TCP/IP模型，这种模型将上面的3层模型统一的表示成应用层。<br><img src="/images/pasted-20.png" alt="upload successful"></p>
<p>为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。在进行网络通信的时候如打开一个网页，数据在发送端(这里指客户端)会从上到下进行封装，然后传输到服务端后，数据会自下而上进行解封装。最后获取上层数据。</p>
<p>我们在进行网络通信的过程中，可以使用http这样应用层的协议，但是当没有协议满足我们的需求的时候，我们需要自主与TCP/UDP进行交互，这时候就有了socket，这是建立在传输层上的一个抽象层，帮助我们与tcp/ip建立连接进行通信，我们可以把它看作两个主机进行双向通信的端点。socket主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。</p>
<h4 id="二-socket工作流程"><a href="#二-socket工作流程" class="headerlink" title="二. socket工作流程"></a>二. socket工作流程</h4><p><img src="/images/pasted-21.png" alt="upload successful"><br>socket是一种打开——读/写——关闭的模式的实现，使用TCP协议进行通讯为例。一共分为服务端socket和客户端socket。服务端socket负责监听客户端连接请求，当客户端发送请求时，两端进行通信。具体流程如下：</p>
<ul>
<li>1.服务端根据地址类型、socket类型、协议创建socket。</li>
<li>2.服务端为socket绑定ip地址和端口号。</li>
<li>3.服务器socket监听端口号请求，随时准备接受客户端发来的请求，这时候服务器的socket并没有被打开。</li>
<li>4.客户端创建socket</li>
<li>5.客户端打开socket，根据服务器的ip地址和端口号试图连接服务器socket</li>
<li>6.服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求。</li>
<li>7.客户端连接成功，向服务端发送连接状态信息。</li>
<li>8.服务器accept方法返回，连接成功</li>
<li>9.客户端向socket写入信息</li>
<li>10.服务器读取信息</li>
<li>11.客户端关闭</li>
<li>12.服务器关闭</li>
</ul>
<h5 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1.三次握手"></a>1.三次握手</h5><p>在客户端和服务端建立TCP连接的过程中会发生有名的<strong>三次握手</strong></p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<p>第一次握手：客户端会尝试连接服务器，向服务器发送syn包，syn=j，客户端进入syn_send状态等待服务器确认。</p>
<p>第二次握手：服务器接收客户端syn包并确认(ack=j+1),同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISHED(已确认)，完成三次握手。</p>
<p>值得强调的是<strong>accept()</strong>这个方法，内核会创建两个队列，SYN队列和accept队列，其中accept队列的长度由backlog指定。服务器在调用accept之后，阻塞，等待accept队列有元素，当三次握手结束后服务器会把客户端从syn队列转移到accept队列，而accept()被唤醒，从accept队列中取出请求方，重新建立一个socket用于准备发送和接收数据，原来的socket还在监听哪个端口。换一句话说，socket()返回的套接字用于监听(listen)和接受(accept)客户端请求，这个套接字不能用于与客户端之间发送和接受数据。accept()接受一个客户端的连接请求，并返回一个新的套接字。所谓“新的”就是说这个套接字与socket()返回的套接字不是同一个socket。这个新的套接字用于与这次接受的客户端之间的通信。</p>
<h5 id="2-四次握手"><a href="#2-四次握手" class="headerlink" title="2.四次握手"></a>2.四次握手</h5><p>当客户端发送信息完毕之后，客户端会与服务端断开连接，此时会发生<strong>4次挥手</strong>。<br><img src="/images/pasted-24.png" alt="upload successful"></p>
<p>第一次挥手：先由客户端向服务器端发送一个FIN，请求关闭数据传输。</p>
<p>第二次挥手：当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ，此时客户端不再向服务端发送消息，但是服务端还可以向客户端发送信息。</p>
<p>第三次挥手：服务端向客户端发送一个FIN，去告诉客户端关闭应用。</p>
<p>第四次挥手：当客户端收到服务端的FIN时，发送一个ACK给服务器。其中ACK的值等于FIN+SEQ。</p>
<h4 id="三-socket实例"><a href="#三-socket实例" class="headerlink" title="三. socket实例"></a>三. socket实例</h4><h5 id="demo1-同步实例"><a href="#demo1-同步实例" class="headerlink" title="demo1 同步实例"></a>demo1 同步实例</h5><p>这里我抛出来一些简单的socket的demo，先贴出服务端的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">11113</span></span><br><span class="line">BUFSIZE = <span class="number">4096</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcpServer = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpServer.bind(ADDR)</span><br><span class="line">tcpServer.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'waiting for connection...'</span>)</span><br><span class="line">    tcpClient, addr = tcpServer.accept()</span><br><span class="line">    print(addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        data = tcpClient.recv(BUFSIZE)</span><br><span class="line">        print(data.decode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'---------'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        buf = <span class="string">'['</span> + ctime() + <span class="string">']'</span> + data.decode()</span><br><span class="line">        tcpClient.send(buf.encode())</span><br><span class="line"></span><br><span class="line">    tcpClient.close()</span><br><span class="line">tcpServer.close()</span><br></pre></td></tr></table></figure>

<p>服务端会一直监听11113端口，直到有客户端连接进来，会创建一个新的socket用于交换信息。<br>下面是客户端的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'localhost'</span></span><br><span class="line">PORT = <span class="number">11113</span></span><br><span class="line">BUFSIZE = <span class="number">4096</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcpClient = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">tcpClient.connect(ADDR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    data = input(<span class="string">'&gt; '</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    tcpClient.send(data.encode())</span><br><span class="line"></span><br><span class="line">    data = tcpClient.recv(BUFSIZE)</span><br><span class="line">    print(data.decode())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">tcpClient.close()</span><br></pre></td></tr></table></figure>

<p>这个demo基本上涵盖了socket通信的整个流程，但是demo中有一些缺点，因为socket.recv()是阻塞的，所以当服务端执行到recv()的时候，会一直等待，直到客户端发送消息才能够继续往下执行代码。这样的结构对于一些实时性要求比较高的场景很不友好。比如说，我们在用实时的视频流进行监控和一些异常计算，当有异常现象的时候，我们会与巡逻小车进行socket进行通信来处理异常，这就要求我们既要能够实时接收摄像头传来的视频流，又要接巡逻小车发来的指令信号，使用上述的demo作为框架就显得不那么合适了。</p>
<h5 id="2-demo2-异步实例"><a href="#2-demo2-异步实例" class="headerlink" title="2. demo2 异步实例"></a>2. demo2 异步实例</h5><p>有一种解决方法就是使用异步通信来解决，这样我们可以对传来的数据进行监听，当监听到有客户端传来请求时，我们会对传来的消息进行解析处理；当客户端没有传来请求时，服务端就会处理自己的事情。在python中可以使用select完成异步通信，下面有一个demo，这里我只抛出来客户端的demo，服务端的异步处理同客户端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'localhost'</span></span><br><span class="line">PORT = <span class="number">6688</span></span><br><span class="line">BUFSIZE = <span class="number">4096</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line">tcpClient = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">tcpClient.connect(ADDR)</span><br><span class="line"></span><br><span class="line">input = [tcpClient]</span><br><span class="line"><span class="comment"># tcpClient.setblocking(False)</span></span><br><span class="line">print(<span class="string">"["</span>+time.ctime()+<span class="string">"]"</span>  +<span class="string">"发现异常"</span>)</span><br><span class="line">data_exchange = &#123;<span class="string">'Position'</span>:<span class="number">0</span>, <span class="string">'CarArrived'</span>:<span class="literal">False</span>, <span class="string">'ResetCarPosition'</span>:<span class="literal">False</span>, <span class="string">'CarPatrol'</span>:<span class="literal">False</span>&#125;</span><br><span class="line">data = json.dumps(data_exchange)</span><br><span class="line">tcpClient.send(data.encode())</span><br><span class="line">tcpClient.settimeout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    rs, ws, es = select.select(input, [], [], <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> indata <span class="keyword">in</span> rs:</span><br><span class="line">        <span class="keyword">if</span> indata == tcpClient:</span><br><span class="line">            data = tcpClient.recv(BUFSIZE)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                car_recv = data.decode()</span><br><span class="line">                data_exchange = json.loads(car_recv)</span><br><span class="line">                <span class="keyword">if</span> data_exchange[<span class="string">'CarPatrol'</span>] == <span class="literal">True</span>:</span><br><span class="line">                    print(<span class="string">"["</span>+time.ctime()+<span class="string">"]"</span>  +<span class="string">"小车已经就绪，重置实验"</span>)</span><br><span class="line">                    data_exchange = &#123;<span class="string">'Position'</span>:<span class="number">0</span>, <span class="string">'CarArrived'</span>:<span class="literal">False</span>, <span class="string">'ResetCarPosition'</span>:<span class="literal">False</span>, <span class="string">'CarPatrol'</span>:<span class="literal">False</span>&#125;</span><br><span class="line">                <span class="keyword">elif</span> data_exchange[<span class="string">'CarArrived'</span>] == <span class="literal">True</span>:</span><br><span class="line">                    print(<span class="string">"["</span>+time.ctime()+<span class="string">"]"</span>  +<span class="string">"小车已经到达异常点，开始处理异常"</span>)</span><br><span class="line">                    time.sleep(<span class="number">3</span>)</span><br><span class="line">                    print(<span class="string">"["</span>+time.ctime()+<span class="string">"]"</span>  +<span class="string">"处理异常结束，小车归位"</span>)</span><br><span class="line">                    data_exchange[<span class="string">'ResetCarPosition'</span>] = <span class="literal">True</span></span><br><span class="line">                    data = json.dumps(data_exchange)</span><br><span class="line">                    tcpClient.send(data.encode())</span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcpClient.close()</span><br></pre></td></tr></table></figure>

<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/qq_38131333/article/details/81533192" target="_blank" rel="noopener">网络OSI七层模型、TCP/IP模型以及数据发送封装与解封装过程</a></p>
<p><a href="https://www.cnblogs.com/dolphinX/p/3460545.html" target="_blank" rel="noopener">简单理解Socket</a></p>
<p><a href="https://blog.csdn.net/weixin_42255385/article/details/82119968" target="_blank" rel="noopener">socket中accept()函数的理解</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习基础(2) —Dockerfile</title>
    <url>/2020/05/26/Docker-%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-2-%E2%80%94dockerfile/</url>
    <content><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>今天带来dockerfile的第二篇文档————Dockerfile，Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。我们可以用java的源码和class文件进行类比，如果我们将image文件比做为一个个类文件，那么Dockerfile就可以看成是源码文件。当我们在Dockerfile文件中写好我们希望构建的镜像之后，可以使用docker build来读取Dockerfile中的指令构建我们的镜像。</p>
<h4 id="一-Dockerfile相关指令以及build指令"><a href="#一-Dockerfile相关指令以及build指令" class="headerlink" title="一. Dockerfile相关指令以及build指令"></a>一. Dockerfile相关指令以及build指令</h4><ul>
<li>FORM 基础镜像，当前新镜像是基于哪个镜像的</li>
<li>MAINTAINER 镜像维护者的姓名和邮箱</li>
<li>RUN 容器构建时需要运行的命令</li>
<li>EXPOSE 当前容器对外暴露出的端口</li>
<li>WORKDIR 指定在创建容器后，终端默认登陆进来的工作目录，一个落脚点</li>
<li>ENV 用来在构建镜像过程中设置环境变量</li>
<li>ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li>
<li>COPY 类似ADD，拷贝文件和目录到镜像中，注意这个不会解压</li>
<li>VOLUME 容器数据卷，用于数据保存和持久化操作</li>
<li>CMD 指定一个容器启动时要运行的命令，dockerfile可以有多个cmd，但是只有最后一个生效</li>
<li>ENTRYPOINT 指定一个容器启动时要运行的命令，不会被覆盖，会追加</li>
<li>ONBUILD 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild会被触发，类似于一个触发器</li>
</ul>
<p>build指令解释如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>
<p>关于options有一些说明：</p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
<li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>
<li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p>下面我们举一个例子来构建自己的dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM contos</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success-------ok&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们引入原始的centos镜像，然后设置工作路径为 /usr/local，并在这个linux系统中装入vim和net-tools组建，最后我们输出我们的工作路径和success。</p>
<p>使用build指令进行镜像构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t mycentos:1.3 .</span><br></pre></td></tr></table></figure>

<p>这里我遇到了一个坑，就是我是在根目录下构建的images，就会出现问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error checking context: &#39;no permission to read from&#39;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;route&#x2F;flush&#39;&#39;.</span><br></pre></td></tr></table></figure>
<p>这里我们一定不要在根目录下进行build操作。</p>
<p>最终结果就是成功构建，我们使用docker images 可以看到：<br><img src="/images/pasted-18.png" alt="upload successful"></p>
<h4 id="二-参考文献"><a href="#二-参考文献" class="headerlink" title="二. 参考文献"></a>二. 参考文献</h4><p><a href="https://www.bilibili.com/video/BV18b411K7q7" target="_blank" rel="noopener">尚硅谷docker核心技术</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">docker官方文档</a><br><a href="https://www.runoob.com/docker/docker-build-command.html" target="_blank" rel="noopener">docker build 命令 菜鸟教程</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>dock er</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 基础学习(1)</title>
    <url>/2020/05/23/Docker-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="docker基础学习-1"><a href="#docker基础学习-1" class="headerlink" title="docker基础学习(1)"></a>docker基础学习(1)</h3><p>今天在天池参加了一个比赛，里面涉及到了docker的容器技术的打包，之前一直没有接触过这些东西，所以乘着周末学习了一些docker基础知识。</p>
<h4 id="一-什么是docker"><a href="#一-什么是docker" class="headerlink" title="一. 什么是docker"></a>一. 什么是docker</h4><p>我们从官方文档里面可以看到，docker是为程序员提供一个可以构建、运行和移植的容器。这个容器可以帮助程序员们快速部署应用，这样的功能被称之为容器化。</p>
<p>容器化有以下几个特点：</p>
<ul>
<li>灵活：即使是很复杂的程序，也可以被放在容器中。</li>
<li>轻量级：容器内的应用运行于主机的内核系统，并可以共享内核资源，这样就比虚拟机更轻量化，可以快速创建和启动。</li>
<li>可移植性：容器可以在本地创建，在云端部署，并在任何地方运行。</li>
<li>松耦合： 容器具有高度的封装性，可以在不破坏其他容器的前提下完成容器的升级或替换。</li>
<li>可扩展： 我们可以自动扩充并自动部署容器副本。</li>
<li>安全性：我们不需要手动配置任何参数，容器会帮助我们自动约束和隔离应用。</li>
</ul>
<p>docker容器并不仅仅是一个正在运行的线程，它增加了一些封装的功能使得其与主机和其他的容器相互隔离，实现隔离功能的最主要的原因是容器可以和内部的镜像文件进行交互，一个镜像文件包括了程序运行的一切代码或二进制文件、依赖项、以及所需的任何其他的文件系统对象。</p>
<h4 id="二-docker和VM的对比"><a href="#二-docker和VM的对比" class="headerlink" title="二. docker和VM的对比"></a>二. docker和VM的对比</h4><p>由下图我们可以看到，docker在linux本地运行，并与其他容器共享主机的内核，当他运行一个独立的进程的时候，不会占用其他可执行文件的内存，容器内部只有程序以及所依赖的二进制文件和依赖哭，并与其他容器相隔离，这种轻巧的特性使得容器可以在几秒内启动。<br><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>相比之下虚拟机的虚拟的是整个操作系统，包括硬件的设置，这样的方式使得VM会产生大量的开销，超出了应用程序逻辑所消耗的的开销。</p>
<h4 id="三-docker架构"><a href="#三-docker架构" class="headerlink" title="三. docker架构"></a>三. docker架构</h4><p>在看架构图之前，我们先来了解一下docker的三个基本概念：镜像、容器、仓库。</p>
<ul>
<li>镜像：镜像是只读，里面有需要运行的文件。它通常是用来创建容器的，镜像可以创建多个容器；我们可以在本地创建镜像也可以通过docker pull从仓库中下载。</li>
<li>容器：容器是镜像的运行的一个实例，我们在使用镜像创建容器的时候可以配置一定的参数，来约束容器的运行。容器的运行是相互独立的，容器之间是不会影响的，这样可以保证容器可以运行在一个相对安全的地方。</li>
<li>仓库：仓库是用来管理、存储镜像的，最有名的仓库就是docker hub，其他的比如国内阿里云的镜像仓库、网易晕的镜像仓库都是用来管理镜像的远程仓库，他们为我们提供下载上传渠道。<br><img src="/images/pasted-17.png" alt="upload successful"></li>
</ul>
<p>如上图，docker架构一共分为三个部分，docker 客户端， docker服务端，和docker注册中心。docker客户端用于发送docker指令，并与docker的守护进程进行通信，守护进程会对指令进行分析，并执行指令，注册中心就是仓库，它用来共享和管理dicker镜像，当我们使用docker pull的时候，docker守护进程会从指定的仓库中拉取镜像并放到本地，这样我们在使用docker run创建容器的时候，就可以直接使用本地的镜像直接创建容器。</p>
<h4 id="四-docker常用指令"><a href="#四-docker常用指令" class="headerlink" title="四. docker常用指令"></a>四. docker常用指令</h4><p>docker 有一些比较常用的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 从仓库拉取镜像</span><br><span class="line">docker pull [image name:tag]</span><br><span class="line">2. 查看本地的所有镜像</span><br><span class="line">docker images</span><br><span class="line">3. 查看运行的容器</span><br><span class="line">docker ps</span><br><span class="line">4. 查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">5. 删除镜像</span><br><span class="line">docker rmi [image name:tag]</span><br><span class="line">6. 启动、停止、重启容器命令</span><br><span class="line">docker start container_name&#x2F;container_id</span><br><span class="line">docker stop container_name&#x2F;container_id</span><br><span class="line">docker restart container_name&#x2F;container_id</span><br><span class="line">7.  -i 以交互模式运行容器</span><br><span class="line">	-t 为容器重新分配一个伪输入终端</span><br><span class="line">    -d 在后台运行  </span><br><span class="line">docker run -i -t container_name&#x2F;container_id</span><br><span class="line">8. 删除容器的命令：</span><br><span class="line">docker rm container_name&#x2F;container_id</span><br><span class="line">9. 查看docker信息</span><br><span class="line">docker info</span><br><span class="line">10. 使用镜像创建docker容器</span><br><span class="line">docker run container_name&#x2F;container_id</span><br><span class="line">11. 查看docker 日志</span><br><span class="line">	-t 打印时间</span><br><span class="line">    -f 持续打印</span><br><span class="line">    -tail 显示日志总数</span><br><span class="line">docker logs</span><br><span class="line">12. 进入后台</span><br><span class="line">docker attach container_id</span><br><span class="line">13. 进入后台，退出容器不会停止</span><br><span class="line">docker exec -it container_id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>更多的指令我们可以在docker –help中查看。</p>
<h4 id="四-参考文献"><a href="#四-参考文献" class="headerlink" title="四. 参考文献"></a>四. 参考文献</h4><p><a href="https://www.bilibili.com/video/BV18b411K7q7" target="_blank" rel="noopener">尚硅谷docker核心技术</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">docker官方文档</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>dokcer</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-2.2.6 无法配置@ConfigurationProperties</title>
    <url>/2020/04/24/SpringBoot-2-2-6-%E6%97%A0%E6%B3%95%E9%85%8D%E7%BD%AE-ConfigurationProperties/</url>
    <content><![CDATA[<p>今天在使用SpringBoot 2.2.6 配置@ConfigurationProperties注解是，发生错误，看一些博客也没有解决问题，在这里记录一下。</p>
<p>首先查找blog，发现在pom添加 spring-boot-configuration-processor配置包就可以了，于是去maven依赖包中查找，代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>但是maven始终无法解析这个依赖包，可能还未上传的缘故，解决方法，将依赖包的版本往前退一个，改为2.1.6就可以了</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(3)——代理模式</title>
    <url>/2020/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>之前我们说过反射机制，今天我们聊一聊反射机制相关的一个设计模式————代理模式，代理模式中的动态代理就是应用了我们反射来动态生成代理对象完成方法调用。</p>
<h3 id="一-代理模式概念"><a href="#一-代理模式概念" class="headerlink" title="一. 代理模式概念"></a>一. 代理模式概念</h3><p>代理模式是给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。</p>
<p>当我们想对一个对象增加一些附加的功能，例如权限的验证、增加日志功能，同时我们又不想破坏对象本身的结构，我们就可以创建一个和这个对象功能相同的代理对象，通过对代理对象的方法调用，间接调用被代理的对象，还可以在方法调用的前后增加一些附加的功能，以达到增强对象的目的。</p>
<p>代理模式一共有三种，静态代理模式、动态代理模式、gclib代理模式。</p>
<h3 id="二-静态代理模式"><a href="#二-静态代理模式" class="headerlink" title="二. 静态代理模式"></a>二. 静态代理模式</h3><p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>如图，我们在有一个ITeacherDao接口，然后我们又创建一个类TeacherDao实现了ITeacherDao接口，当我们在使用这个类的时候，我们希望对类中实现的teache方法做一些增强。这里我们创建TeacherProxy代理类同样实现了ITeacherDao接口，并通过构造函数，传入接口参数来间接对TeacherDao形成依赖关系。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">teach</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师教学生"</span> + name);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITeacherDao target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用接口来代理目标乐居</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeacherProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">teach</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理开始"</span>);</span><br><span class="line">        String stu = target.teach(name);</span><br><span class="line">        System.out.println(<span class="string">"代理结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们向TeacherProxy传入ITeacherDao对象target，并通过构造函数传入被代理对象，在实现teach方法的过程中，通过调用被代理类的teach方法达到方法增强的效果。在实现过程中我们用到了泛型操作，这使得我们可以创建新的ITeacherDao实现类，而无需修改代理类的代码。</p>
<p>静态代理的优点：</p>
<ul>
<li>易于理解和实现</li>
<li>代理类和真实类的关系是编译期静态决定的，和下文马上要介绍的动态代理比较起来，执行时没有任何额外开销。</li>
</ul>
<p>静态代理的缺点：<br>对于每一个接口都需要一个创建新的代理类，当一个工程创建的接口增多时，我们需要创建和维护的代理类也会增多，这无疑是增加工程的代码量和复杂度，不易于管理和维护。</p>
<h3 id="三-动态代理模式"><a href="#三-动态代理模式" class="headerlink" title="三. 动态代理模式"></a>三. 动态代理模式</h3><p>动态代理模式也叫做JDK代理模式，它是通过调用JDK的Proxy类newProxyInstance()来实现对象代理，他会使代理类在运行时动态的生成。<br><strong>JDK中生成代理对象的API：</strong></p>
<p>代理类所在包:java.lang.reflect.Proxy<br>JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class [] interfaces, InvocationHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>这是一个静态方法，且接收的三个参数依次为:</p>
<ul>
<li>ClassLoader loader： 指定当前被委托对象使用类加载器,用null表示默认类加载</li>
<li>Class [] interfaces： 指定被委托对象实现的接口。</li>
<li>InvocationHandler handler： 调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入</li>
</ul>
<p>java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法负责集中处理动态代理类上的所有方法调用。</span></span><br><span class="line"><span class="comment">//第一个参数既是代理类实例，</span></span><br><span class="line"><span class="comment">//第二个参数是被调用的方法对象</span></span><br><span class="line"><span class="comment">// 第三个参数是调用方法的参数。</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>
<p>当我们在调用代理类的方法的时候，代理类会转而进入到InvocationHandler的invoke方法中从而操作被代理对象调用相应的方法。这样我们就可以对被代理对象进行统一的处理，也可以更具参数的不同对被代理对象进行风别处理。</p>
<p>我们在使用JDK动态代理时，通过创建一个代理工厂生成代理对象，并动态执行被代理对象的方法调用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNewInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object o = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"代理开始"</span>);</span><br><span class="line">                        Object ObjectReturn = method.invoke(target, args);</span><br><span class="line">                        System.out.println(<span class="string">"代理结束"</span>);</span><br><span class="line">                        <span class="keyword">return</span> ObjectReturn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们点开newProxyInstance源码可以看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">//生成代理类</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//利用代理类生构造器</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用构造器在生成实例</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到newProxyInstance现为我们生成了一个代理类，再利用代理类生成一个构造器，最后用构造器生成代理对象。这里我们看到构造器传入了constructorParams，我们追踪一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br></pre></td></tr></table></figure>
<p>发现constructorParams是一个包含了InvocationHandler.class的数组，其实我们最终生成代理类会包含一个InvocationHandler对象h，当我们调用代理对象的方法的时候，实际上调用调用的是h的invoke()方法进而调用实际的方法。我们接下来用idea的反编译看一下生成的class类文件，反编译的操作是在VM options中添加：-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mjj.proxy.JDKproxy.ITeacherDao;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">teacher</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.mjj.proxy.JDKproxy.ITeacherDao"</span>).getMethod(<span class="string">"teacher"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们可以清晰的看到代理类在初始化的时候通过反射加载方法，在调用方法的时候实际上是调用我们传入的InvocationHandler的方法。本质上代理类和被代理类都实现了相同的接口，拥有相似的结构，而在方法的调用上都是通过反射实现对代理类的调用。</p>
<p>我们维护的动态代理类生成器ProxyFactory无需实现接口，具有可维护、易扩展的特点，具体的源代码可以参考这个链接（<a href="https://blog.csdn.net/yhl_jxy/article/details/80586785" target="_blank" rel="noopener">JDK动态代理实现原理(jdk8)</a>）但是JDK动态代理有一个无法避免的缺点就是，被代理类必须实现接口。若我们想代理一个没有实现接口的类，我们就不能使用这种方法，而只能使用我们下面介绍的cglib代理。</p>
<h3 id="三-cglib代理模式"><a href="#三-cglib代理模式" class="headerlink" title="三. cglib代理模式"></a>三. cglib代理模式</h3><p>cglib代理模式不需要被代理的对象实现接口，其底层是通过ASM字节码框架生成类的字节码，达到动态创建类的目的。它利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。下面我借用一下别人的uml类图来说明一下：</p>
<p><img src="/images/pasted-14.png" alt="upload successful"><br>cglib通过先创建了代理类并实例化proxy，proxy通过继承关系继承被代理类，然后通过对父类方法的重写以达到业务增强的效果。<br>实例代码如下：</p>
<p><strong>创建目标类：Target：</strong>方法简单输出一句话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行目标类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建目标类的方法增强拦截器：TargetMethodInterceptor：</strong>在拦截器内部，调用目标方法前进行前置和后置增强处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">                            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法拦截增强逻辑-前置处理执行"</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"方法拦截增强逻辑-后置处理执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成代理类，并测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置生成代理类的父类class对象</span></span><br><span class="line">        enhancer.setSuperclass(Target<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置增强目标类的方法拦截器</span></span><br><span class="line">        MethodInterceptor methodInterceptor = <span class="keyword">new</span> TargetMethodInterceptor();</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理类并实例化</span></span><br><span class="line">        Target proxy = (Target) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用代理类调用方法</span></span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出：可以看到成功进行了业务增强的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法拦截增强逻辑-前置处理执行</span><br><span class="line">执行目标类的方法</span><br><span class="line">方法拦截增强逻辑-后置处理执行</span><br></pre></td></tr></table></figure>

<h3 id="四-动态代理和cglib对比"><a href="#四-动态代理和cglib对比" class="headerlink" title="四. 动态代理和cglib对比"></a>四. 动态代理和cglib对比</h3><ul>
<li>实现方式不同<br>动态代理是利用<strong>相同接口</strong>实现和被代理类相同结构代理类，再利用<strong>反射机制</strong>实现方法代理，而cglib是利用<strong>asm框架</strong>操作字节码文件生层代理类，再利用<strong>继承关系</strong>实现代理。</li>
<li>使用方式不同<br>动态代理要求代理对象必须实现接口，而cglib虽然不需要被代理对象实现接口，但是由于使用了继承关系，所以cglib无法代理final对象。</li>
<li>效率对比<br>关于两者之间的性能的话，网上有人对于不通版本的jdk进行测试，经过多次试验，测试结果大致是这样的，在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了，但是JDK动态代理和CGLIB动态代理的适用场景还是不一样的哈！</li>
</ul>
<h3 id="五-参考文献"><a href="#五-参考文献" class="headerlink" title="五. 参考文献"></a>五. 参考文献</h3><p><a href="https://segmentfault.com/a/1190000009235245" target="_blank" rel="noopener">Java的三种代理模式</a><br><a href="https://zhuanlan.zhihu.com/p/41869538" target="_blank" rel="noopener">Java代理设计模式的四种具体实现：静态代理和动态代理</a><br><a href="https://www.zhihu.com/question/20794107" target="_blank" rel="noopener">Java 动态代理作用是什么？</a><br><a href="https://zhuanlan.zhihu.com/p/106336169" target="_blank" rel="noopener">Java：聊聊JDK和CGLib动态代理实现和区别</a><br><a href="https://www.jianshu.com/p/3caa0c23a157" target="_blank" rel="noopener">设计模式（11）动态代理 JDK VS CGLIB面试必问</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入反射机制(1)——基础</title>
    <url>/2020/04/05/%E6%B7%B1%E5%85%A5%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-1-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>之前在看springIOC的视频，里面设计到了很多反射的知识，我对反射一直停留在会用的阶段，借着这个机会好好学习一下Java的反射机制。</p>
<h3 id="一-反射基本概念"><a href="#一-反射基本概念" class="headerlink" title="一. 反射基本概念"></a>一. 反射基本概念</h3><p>反射机制是指在<strong>程序运行期间对于任意一个类可以知道它的全部属性和方法，对于任意一个对象可以调用他的所有方法。</strong>这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。</p>
<p>一般来说我们可以通过new一个对象来达到正向创建对象的目的，这样创建出来的对象类型是编译期可知的，而我们可以借助反射机制在运行期间通过Class动态创建对象，这样的对象往往在编译期间是不可知的。</p>
<p>Java 反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；（isInstance）</li>
<li>在运行时构造任意一个类的对象；（newInstance）</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法（invoke）</li>
</ul>
<h3 id="二-反射的使用"><a href="#二-反射的使用" class="headerlink" title="二. 反射的使用"></a>二. 反射的使用</h3><h4 id="Class类获取"><a href="#Class类获取" class="headerlink" title="Class类获取"></a>Class类获取</h4><p>提到反射的使用，就不得不提class类，class类是标示一个运行时类的具体信息，它由JVM在装载一个类的时候自动创建用于记录该类的相关信息并存放在虚拟机堆中。他的创建方式一共有三种</p>
<p>第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure>

<p>第二种是使用 类.class直接获取类的Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三种是通过对象的getClass()方法获取Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">Class clz = str.getClass()</span><br></pre></td></tr></table></figure>

<p>这里第二种方式需要在编译期前就确定Class类，这与反射机制的编译时不可知，运行时可知的特点相矛盾，而第三种已经创建出类的实体，再利用getClass方法获取类对象，对于反射来说已经意义不大了，所以我们再利用反射的时候通常使用第一种方式，通过全类名的方式获取class类，也符合编译器不可知的特点。</p>
<h4 id="获取对象实例"><a href="#获取对象实例" class="headerlink" title="获取对象实例"></a>获取对象实例</h4><p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p>
<p>第一种：通过 Class 对象的 newInstance() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">Object object = clz.newInstance();</span><br></pre></td></tr></table></figure>

<p>这种方式只适用于适用无参的构造函数，有参数的无法使用。</p>
<p>第二种：通过 Constructor 对象的 newInstance() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">Constructor cons = clz.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Object object = constructor.newInstance(<span class="string">"111"</span>);</span><br></pre></td></tr></table></figure>
<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p>
<h4 id="获取类属性、方法"><a href="#获取类属性、方法" class="headerlink" title="获取类属性、方法"></a>获取类属性、方法</h4><p>属性的获得一共有两种getField()和getDeclaredField()</p>
<p>第一种getField()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; bookclz = Class.forName(<span class="string">"com.mjj.book.Book"</span>);</span><br><span class="line">Field author = bookclz.getField(<span class="string">"author"</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式可以获取类内以public方式声明的属性以及继承的public的属性，对于private和默认声明的属性无法获取。</p>
<p>第二种getDeclaredField()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; bookclz = Class.forName(<span class="string">"com.mjj.book.Book"</span>);</span><br><span class="line">Field author = bookclz.getDeclaredField(<span class="string">"author"</span>);</span><br><span class="line">author.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(author);</span><br></pre></td></tr></table></figure>
<p>这种属性的获取方式可以获取到本类private属性的值，但是当我们在使用这样私有属性的时候，我们需要设置setAccessible(true);才可以正确使用。</p>
<p>方法获取的方式一样都有两种分别是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br><span class="line"><span class="comment">//getMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method[] <span class="title">getMethods</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h3 id="三-参考文献"><a href="#三-参考文献" class="headerlink" title="三. 参考文献"></a>三. 参考文献</h3><p><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">大白话说Java反射：入门、使用、原理</a><br><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析Java反射（1） - 基础</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式笔记(2)——工厂模式</title>
    <url>/2020/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="一-工厂模式概念"><a href="#一-工厂模式概念" class="headerlink" title="一. 工厂模式概念"></a>一. 工厂模式概念</h3><p>工厂模式是一种创建型模式，他的意义是专门创建一个类，我们在这个类中去完成我们需要创建的对象，这样既可以方便管理，又可以提高代码的可扩展性和灵活性。工厂模式包括简单工厂模式、工厂方法模式、抽象工厂模式，其中工厂方法模式就是我们常说的工厂模式。</p>
<p>我们在开发初期通常是直接通过new来创建一个对象的，这样的方式无疑是最简单的，但是这样创建对象有很多不足的地方，我们可以通过一个例子来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserDAO udao;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LoginAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		udao = <span class="keyword">new</span> JDBCUserDAO(); <span class="comment">//创建对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//其他代码</span></span><br><span class="line">		udao.findUserById(); <span class="comment">//使用对象</span></span><br><span class="line">		<span class="comment">//其他代码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在LoginAction类中创建了一哦个UserDao对象udao，并在execute()方法中调用了udao对象的findUserById()方法。这样LoginAction对udao既有创建职责又有使用职责，在同一个类中将两种职责耦合在了一起，当我们有修改需求的时候，比如我们要创建的是UserDAO的子类的时候，我们就需要修改LoginAction()中的代码，违背了开闭原则。</p>
<p>而工厂模式是通常解决这个问题好方法，我们可以创建一个UserDaoFactory由它来专门负责UserDao类及其子类对象的创建。当我们需要增加UserDao子类或者修改构造函数的时候，我们只需要维护UserDaoFactory而不影响其他相关类的使用。工厂模式一只强调的是当两个类A和B发生关联的时候，<strong>两者只会发生A使用B或者A创建B这两种关系，而不是同时发生。</strong> 并且工厂类帮我们封装了创建对象的细节，我们只要传递相应的参数，就可以帮助我们创建具体的对象。下面我们来介绍依次介绍3个工厂工行模式。</p>
<h3 id="二-简单工厂模式"><a href="#二-简单工厂模式" class="headerlink" title="二. 简单工厂模式"></a>二. 简单工厂模式</h3><p>简单工厂模式又叫做静态工厂模式，他并不属于23种经典模式之中，我们从一个例子中先体验简单工厂模式。</p>
<p>比如说我们需要生产pizza，一共有奶酪pizza和希腊pizza两种不同口味，我们创建一个工厂来负责生产这两种口味的pizza，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开动啦！吃："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备一个奶酪披萨"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备一个希腊披萨"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Pizza pizza =<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">"cheese"</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">            pizza.setName(<span class="string">"奶酪披萨"</span>);</span><br><span class="line">            pizza.prepare();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"greek"</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">            pizza.setName(<span class="string">"希腊披萨"</span>);</span><br><span class="line">            pizza.prepare();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pizza pizza = SimpleFactory.createPizza(<span class="string">"greek"</span>);</span><br><span class="line">        <span class="keyword">if</span>(pizza!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pizza.eat();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有pizza"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们在订单中需要创建一个pizza的时候，我们会调用SimpleFactory中的方法createPizza来创建一个对象，SimpleFactory会根据参数来自主判断创建对象的类型。</p>
<p>这种方法使用起来比较简单，表面上解决了OrderPizza中耦合的问题，但是他只是将逻辑判断中的代码转移到了工厂中，这会使得工厂类不满足ocp原则，在需要修改代码的时候我们需要维护工厂类的逻辑判断。</p>
<h3 id="二-工厂方法模式"><a href="#二-工厂方法模式" class="headerlink" title="二. 工厂方法模式"></a>二. 工厂方法模式</h3><p>为了解决简单工厂模式的缺点，使得工厂类更加符合开闭原则。我们先使用一个抽象类去定义一个抽象的创建对象的方法，再由子类去继承这个抽象类，去专门创建具体的对象。</p>
<p>还是上一个例子，但是我们分别创建了奶酪pizza工厂和希腊pizza工厂去继承一个抽象的工厂类。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizzaFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GreekPizza greekPizza = <span class="keyword">new</span> GreekPizza();</span><br><span class="line">        greekPizza.setName(<span class="string">"希腊披萨"</span>);</span><br><span class="line">        <span class="keyword">return</span> greekPizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizzaFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CheesePizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样写的好处就是，我们在增加或者删除不同口味pizza的时候，我们只需要创建不同的工厂去生产不同的pizza就可以了，而不用去修改factory中的代码。但是工厂方法模式也有一定的缺陷，就是当我们的产品增多时我们需要创建大量的具体工厂去生产不同的对象，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h3 id="二-抽象工厂模式"><a href="#二-抽象工厂模式" class="headerlink" title="二. 抽象工厂模式"></a>二. 抽象工厂模式</h3><p>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
<p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p>
<ul>
<li>产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li>产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ul>
<p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。<br>这里我们看一个uml图理解一下</p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</p>
<p>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>视频：<br><a href="https://www.bilibili.com/video/av57936239" target="_blank" rel="noopener">尚硅谷Java设计模式，韩顺平图解java设计模式</a></p>
<p>文献：<br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html" target="_blank" rel="noopener">3. 抽象工厂模式(Abstract Factory)</a></p>
<p><a href="https://segmentfault.com/a/1190000015050674" target="_blank" rel="noopener">深入理解工厂模式</a></p>
<p><a href="https://blog.csdn.net/lovelion/article/details/7523392" target="_blank" rel="noopener">创建对象与使用对象——谈谈工厂的作用</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式笔记(1)——单例模式</title>
    <url>/2020/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式顾名思义就是保证某个类只有一个实例的设计方式，他负责自己创建实例，且保证实例的唯一性。这种实例的唯一性，可以避免某些高频率使用的对象被频繁的创建和销毁，提高了效率，节省了系统资源。单例模式向外界提供了创建该类实例的方法，并私有化构造方法，使得外界不能直接通过new构造实例。</p>
<p>单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级<br>对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)。</p>
<p>单例模式分为饿汉式和饱汉式，下面我们来详细介绍一下这两种设计模式。</p>
<h3 id="二-饿汉式"><a href="#二-饿汉式" class="headerlink" title="二. 饿汉式"></a>二. 饿汉式</h3><p>饿汉式是通过直接声明一个该类静态成员变量并在加载的时候就直接创建实例。我们可以用以下的方法进行构造，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjj.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        <span class="keyword">boolean</span> equals = instance.equals(instance1);</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>饿汉式直接在内部声明对象实例，并提供了一个返回对象实例的方法，这样类在加载的时候就会自动创建一个该类的实例。这种方法实现起来简单易懂，并且自动支持线程安全(由jvm保证)。但是饿汉式的方法又一个缺点就是类在加载的时候就会被创建该实例，不管有没有被使用到，这就导致如果这个实例没有被用到的化，就会造成资源浪费。</p>
<h3 id="三-懒汉式"><a href="#三-懒汉式" class="headerlink" title="三. 懒汉式"></a>三. 懒汉式</h3><p>如果说饿汉式是一种空间换时间的方法，那么懒汉式就是就是一种时间换空间的方法。懒汉式提供一种懒加载的方式，只有在需要的时候才会创建该类的实例对象。他有很多种方法，下面我们来具体看一下。</p>
<h4 id="1-线程不安全"><a href="#1-线程不安全" class="headerlink" title="1. 线程不安全"></a>1. 线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjj.singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式 只有在获取getInstance的时候才会去加载，并且只会加载一次</span></span><br><span class="line"><span class="comment">// 缺点 线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton03 instance = Singleton03.getInstance();</span><br><span class="line">        Singleton03 instance1 = Singleton03.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton03();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种懒汉式将实例化对象封装在方法中，这样可以实现懒加载，也就是只有在用到getInstance()的时候才会加载实例，但是这种方法不是线程安全的，比如有两个线程A和B同时调用getInstance()方法，当A已经进入if(singleton == null)语句之后，还没有跳出if判断语句，B线程也进入到if判断语句，这就会导致创建多个兑现，违背单例模式对象唯一性。为了解决这一问题，我们有3种方法进行改进。</p>
<h4 id="2-双重检查"><a href="#2-双重检查" class="headerlink" title="2. 双重检查"></a>2. 双重检查</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjj.singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton05 instance = Singleton05.getInstance();</span><br><span class="line">        Singleton05 instance1 = Singleton05.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton05 singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton05</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测的方法 不仅线程安全 并且能够解决效率底的问题 建议使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton05<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton05();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法通过两次判断类的实例对象是否被创建，其中第一次判断语句是为了防止线程每一次调用getIntance()都会使用synchronized进行同步，使代码执行效率变高，第二次判断语句是为了防止多线程情况下重复创建对象。这里使用volatile有两个目的，第一是使多线程之间共享资源可见，当一个线程在修改公共资源的时候其他线程能够立刻从内存中读取修改值，第二个好处就是使得指令有序，防止空指针引用。举个例子，当线程A运行到singleton = new Singleton05()时，其实会有3个指令操作</p>
<ul>
<li><ol>
<li>获取对象地址；</li>
</ol>
</li>
<li><ol start="2">
<li>在对象地址上初始化一个Singleton05对象；</li>
</ol>
</li>
<li><ol start="3">
<li>将singleton引用指向对象地址；<br>但是JVM会自动进行指令的优化，他可能会按照1-&gt;2-&gt;3的方式进行也可能会按照1-&gt;3-&gt;2的方式进行，当线程A按照第二种方式操作的时候，且已经将singlton引用指向了对象地址了，这时正好线程B运行到第一个判断语句就会判断成非空，然后返回singleton引用，此时引用并没有初始化对象，就是一个空指针，这样就会造成空指针异常。</li>
</ol>
</li>
</ul>
<h4 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjj.singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton06 instance = Singleton06.getInstance();</span><br><span class="line">        Singleton06 instance1 = Singleton06.getInstance();</span><br><span class="line">        System.out.println(instance == instance1);</span><br><span class="line">        System.out.println(instance.hashCode());</span><br><span class="line">        System.out.println(instance1.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton06</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton06</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton06 singleton = <span class="keyword">new</span> Singleton06();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用静态内部类 不仅线程安全 并且能够解决效率底的问题 建议使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton06 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态内部类的方法是创建一个内部类，并在内部类里面创建静态实例对象，内部类必须是私有的只能由外部类调用，这种方法相当于将多线程安全的问题交给JVM去处理，也是推荐使用的方法。</p>
<h4 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjj.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sinleton07 instance1 = Sinleton07.Instance;</span><br><span class="line">        Sinleton07 instance2 = Sinleton07.Instance;</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Sinleton07&#123;</span><br><span class="line">    Instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methof</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"枚举方法 单例模式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用枚举也是一种比较好的方法，这种方法使用简单，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，也是推荐的方法。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>视频：<br><a href="https://www.bilibili.com/video/av57936239" target="_blank" rel="noopener">尚硅谷Java设计模式，韩顺平图解java设计模式</a></p>
<p>文献：<br><a href="https://blog.csdn.net/FU250/article/details/79721197" target="_blank" rel="noopener">双重检查单例为什么要加volatile</a><br><a href="https://blog.csdn.net/qq_35098526/article/details/79893628" target="_blank" rel="noopener">单例模式懒汉式和饿汉式区别</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记(2)——类加载机制详解</title>
    <url>/2020/03/01/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一-类加载机制概念"><a href="#一-类加载机制概念" class="headerlink" title="一. 类加载机制概念"></a>一. 类加载机制概念</h3><p>我们前面讲到了JVM的工作原理说到，对JAVA源代码编译出来的.class字节码文件，需要通过JVM将字节码转化为底层可识别的机器码，而第一步就是将class文件中的类描述数据加载到虚拟机中。并对数据进行校验、转换解析、初始化，使这些数据最终成为可以被JVM直接使用的Java类型，我们称这样的步骤叫做JVM的类加载机制。</p>
<h3 id="二-类加载过程"><a href="#二-类加载过程" class="headerlink" title="二. 类加载过程"></a>二. 类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备、解析3个阶段统称为连接，它们开始的顺序如下图所示：</p>
<p><img src="/images/pasted-6.png" alt="upload successful"></p>
<p>这里加载、连接、初始化是在JVM装载器中进行的。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p>这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p>
<ul>
<li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li>
<li>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li>
</ul>
<p>下面我们具体介绍加载、连接、初始化这三个过程。</p>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>这样说起来有些难以理解，我们可以举一个简单的例子，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoaderTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Example1.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在类中初始化了一个static int类型的元素a，在加载这个类时，JVM首先会从classpath路径下找到一个叫Example1.class的字节流文件，然后将此字节流文件中的静态数据和静态代码块（这里指的就是我们的static int a）放入到方法区内，并在内存中生成一个Example1对象，这个对象是java.lang.Class类型的<strong>(由加载器提取并放入堆中)</strong>，可以用来访问方法区内属于这个类的各种数据。这里我们Example1.a就是访问可存在方法区中的static int类型元素。</p>
<p><font color="#dd0000">值得注意的是class对象也是存放在堆中，方法区中存放的只是类型数据</font></p>
<p>类的加载方式有很多种，可以从JAR包中、网络获取、JSP文件生成Class文件、从数据库中获取等。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。这里就需要对类加载器有充分的了解，我会在后续详细介绍不同的类加载器。</p>
<p><font color="#dd0000">我们需要注意数组类和非数组类的加载是有一定区别的。</font>数组本身不是通过类加载器创建的，它是通过JAVA虚拟机直接创建的，但是数组中的元素类型最终是靠类加载器创建，一个类加载器遵循一下规则：</p>
<ul>
<li>如果数组的组件类型（指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间被标识</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组），java虚拟机将会吧数组C标记为于引导类加载器相关联</li>
<li>数组类的可见性与他的组件类型相一致，如果组件不是引用类型，那数组类型的可见性默认为public<br/></li>
</ul>
<p>我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoaderTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Example2 [] a = <span class="keyword">new</span> Example2[<span class="number">5</span>];</span><br><span class="line">        Example2 b = <span class="keyword">new</span> Example2();</span><br><span class="line">        System.out.println(a.getClass());</span><br><span class="line">        System.out.println(b.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getClass()表示的是获取实例的类型类，也就是我们在内存空间生成的java.lang.Class类型结果，结果显示为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class [LClassLoaderTest.Example2;</span><br><span class="line">class ClassLoaderTest.Example2</span><br></pre></td></tr></table></figure>
<p>这里可以看到数组也是一个类，但是数组类型和他的组件类型是不一样的，会有[L来标识数组类型。具体内容可以参考一下这篇内容：<a href="https://zhuanlan.zhihu.com/p/83110138" target="_blank" rel="noopener">如何理解数组在Java中作为一个类？</a></p>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。主要有以下几种验证。</p>
<p><strong>文件格式验证：</strong><br>主要验证字节流是否符合Class文件格式的规范，如果符合则把字节流加载到方法区中进行存储。如主次版本号是否在当前虚拟机处理范围内， 开头是否有0xCAFEBABE等。</p>
<p><strong>元数据验证：</strong><br>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</p>
<p><strong>字节码验证：</strong><br>该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<p><strong>符号引用验证：</strong><br>这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分。这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</p>
<p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<ul>
<li>类或方法解析： 判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li>
<li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上下往上递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从下往上递归搜索其父类，直至查找结束，查找流程如下图所示：<br><img src="/images/pasted-7.png" alt="upload successful"></li>
</ul>
<p><font color="#dd0000">最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。</font><br/></p>
<ul>
<li><p>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p>
</li>
<li><p>接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p>
</li>
</ul>
<h4 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h4><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器 &lt;clinit&gt;()方法的过程。<br>这里简单说明下 &lt;clinit&gt;()方法的执行规则:</p>
<pre><code>1、&lt;clinit&gt;（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。

2、&lt;clinit&gt;（）方法与实例构造器&lt;init&gt;（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;（）方法执行之前，父类的&lt;clinit&gt;（）方法已经执行完毕。因此，在虚拟机中第一个被执行的&lt;clinit&gt;（）方法的类肯定是java.lang.Object。

3、&lt;clinit&gt;（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;（）方法。

4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&lt;clinit&gt;（）方法。但是接口鱼类不同的是：执行接口的&lt;clinit&gt;（）方法不需要先执行父接口的&lt;clinit&gt;（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;（）方法。

5、虚拟机会保证一个类的&lt;clinit&gt;（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;（）方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;（）方法完毕。如果在一个类的&lt;clinit&gt;（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</code></pre><p>我们看一段代码来更深入的理解上面的规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoaderTest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Father1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child1.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时的结果是 2</p>
<p>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用<clinit>（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的<clinit>（）方法，根据规则2，在此之前，要先执行完其父类Father的<clinit>（）方法，又根据规则1，在执行<clinit>（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的<clinit>（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的<clinit>（）方法，这样便会将b的赋值为2.</p>
<p>如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的<clinit>（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。</p>
<p>另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p>
<p>Java虚拟机规范中严格规定了<font color="#dd0000">有且只有五种情况必须对类进行初始化：</font><br/></p>
<ul>
<li><ol>
<li>使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。</li>
</ol>
</li>
<li><ol start="2">
<li>通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。</li>
</ol>
</li>
<li><ol start="3">
<li>当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。</li>
</ol>
</li>
<li><ol start="4">
<li>当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。</li>
</ol>
</li>
<li><ol start="5">
<li>使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</li>
</ol>
</li>
</ul>
<p>注意，虚拟机规范使用了“有且只有”这个词描述，这五种情况被称为“主动引用”，除了这五种情况，所有其他的类引用方式都不会触发类初始化，被称为“被动引用”。</p>
<p>被动引用的例子一：<br>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态变量value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">666</span>;</span><br><span class="line">	<span class="comment">//静态块，父类初始化时会调用</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类初始化！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">	<span class="comment">//静态块，子类初始化时会调用</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类初始化！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为： </p>
<p>   父类初始化<br>   33</p>
<p>被动引用的例子二：<br>通过数组定义来引用类，不会触发子类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">//静态变量value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">666</span>;</span><br><span class="line">	<span class="comment">//静态块，父类初始化时会调用</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类初始化！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		SuperClass[] test = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为空白，这里没有触发类SuperClass的初始化阶段，但是会触发[lSuperClass的类初始化，它是由虚拟机自动生成的，这我们在前面的加载这一阶段中已经提到了。</p>
<p>被动引用例子三：<br>刚刚讲解时也提到，静态常量在编译阶段就会被存入调用类的常量池中，不会引用到定义常量的类，这是一个特例，需要特别记忆，不会触发类的初始化！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//常量类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"常量类初始化！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主类、测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果只会输出hell world！不会输出常量类初始化，这是因为final是修饰的HELLOWORLD在编译阶段通过常量传播优化，已经将常量的值”hello world!”存储在NotInit类的敞亮池中，以后NotInit对常量ConstClass.HELLOWORLD的引用实际都会被转化为NotInit类对自身常量池的引用。也就是说NotInit类的Class文件实际上并没有ConstClass类的符号引用入口，这两个类在编译成Class文件之后就没有关系了。</p>
<h3 id="三-类加载器"><a href="#三-类加载器" class="headerlink" title="三. 类加载器"></a>三. 类加载器</h3><p>JVM设计者把类加载阶段中的“通过’类全名’来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p><strong>1.类与类加载器</strong><br>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>
<p><strong>2. 类加载器分类</strong><br>启动类加载器：<br>主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，在工作中它负责加载扩展类加载器和系统类加载器，并作为这些加载器的父加载器，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。</p>
<p>扩展类加载器：<br>它负责加载扩展目录(%JAVA_HOME%/jre/lib/ext)下的jar包，派生与ClassLoader类，父类加载器为启动类加载器，用户可以把自己开发的类打包成jar包放在这个目录下即可扩展核心类以外的新功能。</p>
<p>系统类加载器或称为应用程序类加载器：<br>是指Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</p>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面我们进一步了解它。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><strong>双亲委派模型原理：</strong><br>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，类加载器间的关系如下：</p>
<p><img src="/images/pasted-8.png" alt="upload successful"><br>其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p><strong>双亲委派模型优势</strong><br>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited package name: java.lang</span><br></pre></td></tr></table></figure>

<p><strong>双亲委派破坏</strong></p>
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。<br>    线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p>
<p><img src="/images/pasted-9.png" alt="upload successful"><br>从图可知rt.jar核心包是有Bootstrap类加载器加载的，其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载，因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活。为了进一步证实这种场景，不妨看看DriverManager类的源码，DriverManager是Java核心rt.jar包中的类，该类用来管理不同数据库的实现驱动即Driver，它们都实现了Java核心包中的java.sql.Driver接口，如mysql驱动包中的com.mysql.jdbc.Driver，这里主要看看如何加载外部实现类，在DriverManager初始化时会执行如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DriverManager是Java核心包rt.jar的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">//省略不必要的代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();<span class="comment">//执行该方法</span></span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//loadInitialDrivers方法</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sun.misc.Providers()</span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//加载外部的Driver的实现类</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">              <span class="comment">//省略不必要的代码......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在DriverManager类初始化时执行了loadInitialDrivers()方法,在该方法中通过ServiceLoader.load(Driver.class);去加载外部实现的驱动类，ServiceLoader类会去读取mysql的jdbc.jar下META-INF文件的内容，如下所示</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>而com.mysql.jdbc.Driver继承类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">"Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. "</span></span><br><span class="line">                + <span class="string">"The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释可以看出平常我们使用com.mysql.jdbc.Driver已被丢弃了，取而代之的是com.mysql.cj.jdbc.Driver，也就是说官方不再建议我们使用如下代码注册mysql驱动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//不建议使用该方式注册驱动类</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/cm-storylocker?characterEncoding=UTF-8"</span>;</span><br><span class="line"><span class="comment">// 通过java库获取数据库连接</span></span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root@555"</span>);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>而是直接去掉注册步骤，如下即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/cm-storylocker?characterEncoding=UTF-8"</span>;</span><br><span class="line"><span class="comment">// 通过java库获取数据库连接</span></span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root@555"</span>);</span><br></pre></td></tr></table></figure>

<p>这样ServiceLoader会帮助我们处理一切，并最终通过load()方法加载，看看load()方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//通过线程上下文类加载器加载</span></span><br><span class="line">      ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>很明显了确实通过线程上下文类加载器加载的，实际上核心包的SPI类对外部实现类的加载都是基于线程上下文类加载器执行的，通过这种方式实现了Java核心代码内部去调用外部实现类。我们知道线程上下文类加载器默认情况下就是AppClassLoader，那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码部署到不同服务时会出现问题，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题。ok~.关于线程上下文类加载器暂且聊到这，前面阐述的DriverManager类，大家可以自行看看源码，相信会有更多的体会，另外关于ServiceLoader本篇并没有过多的阐述，毕竟我们主题是类加载器，但ServiceLoader是个很不错的解耦机制，大家可以自行查阅其相关用法。</p>
<h3 id="面试题、"><a href="#面试题、" class="headerlink" title="面试题、"></a>面试题、</h3><p>下面我们看一些面试来回顾一下学习的内容，这也是为以后面试做的一些准备吧。</p>
<ul>
<li>看你简历写得熟悉JVM，那你说说类的加载过程吧？</li>
<li>我们可以自定义一个String类来使用吗？（判断类的唯一性）</li>
<li>什么是类加载器，类加载器有哪些？</li>
<li>多线程的情况下，类的加载为什么不会出现重复加载的情况？</li>
<li>什么是双亲委派机制？它有啥优势？可以打破这种机制吗？</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>视频：</p>
<p><a href="https://www.bilibili.com/video/av83622425" target="_blank" rel="noopener">尚硅谷宋红康JVM教程(java虚拟机详解，jvm从入门到精通)</a></p>
<p>文章：</p>
<p><a href="https://juejin.im/post/5a810b0e5188257a5c606a85" target="_blank" rel="noopener">Java类加载机制（全套）</a><br><a href="https://www.cnblogs.com/aspirant/p/7200523.html" target="_blank" rel="noopener">Java 类加载机制(阿里)-何时初始化类</a><br><a href="https://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">【深入Java虚拟机】之四：类加载机制</a><br><a href="https://blog.csdn.net/ns_code/article/details/17845821" target="_blank" rel="noopener">【深入Java虚拟机】之三：类初始化</a><br><a href="https://blog.csdn.net/zhangliangzi/article/details/51338291" target="_blank" rel="noopener">JVM类加载机制详解（二）类加载器与双亲委派模型</a><br><a href="https://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener"> 深入理解Java类加载器(ClassLoader)</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记(1)——JVM整体概念</title>
    <url>/2020/02/28/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94JVM%E6%95%B4%E4%BD%93%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="一-什么是JVM"><a href="#一-什么是JVM" class="headerlink" title="一. 什么是JVM"></a>一. 什么是JVM</h3><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。  </p>
<p>它是一种能够运行Java bytecode的虚拟机，以堆栈结构机器来进行实做。最早由太阳微系统所研发并实现第一个实现版本，是Java平台的一部分，能够运行以Java语言写作的软件程序。  </p>
<p>Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码（Applet与应用程序）。</p>
<p>作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件符合JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。此外，除了甲骨文，也有其他开源或闭源的实现。 </p>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<p>总之高级语言只要是能够通过编译器生成符合JVM规范的字节码，就可以在JVM上运行。JVM的这种可扩展性也解释了java的 <strong>“一次编译，到处运行的”</strong> 的原因。</p>
<hr>
<h3 id="二-JVM的相关结构"><a href="#二-JVM的相关结构" class="headerlink" title="二. JVM的相关结构"></a>二. JVM的相关结构</h3><h4 id="1-JDK、JRE、JVM的关系结构"><a href="#1-JDK、JRE、JVM的关系结构" class="headerlink" title="1. JDK、JRE、JVM的关系结构"></a>1. JDK、JRE、JVM的关系结构</h4><p><img src="/images/pasted-1.png" alt="upload successful"></p>
<p>如上图所示：JDK包含了JAVA程序设计语言、JVM、JAVA API类库这三个部分，用于支持JAVA程序开发的最小环境，是JAVA程序开发的<strong>必需品</strong>；JRE则只包含了JVM以及JAVA API类库中的JAVA SE API子集，JRE不能够用于JAVA程序开发，只是为JAVA程序运行提供一个标准环境。</p>
<h4 id="2-JVM工作原理"><a href="#2-JVM工作原理" class="headerlink" title="2. JVM工作原理"></a>2. JVM工作原理</h4><p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p>如图所示，java源代码通过编译器转化为字节码，JVM将字节码读取、校验，并逐条解释成操作系统可读取的机器码。对于一些热点代码(即多次重复出现的代码)，JVM将会通过JIT代码生成器对这些代码进行二次编译直接生成机器码，避免以后重复解释，且提升JVM工作效率。</p>
<p>这里解释一下为什么不先将字节码全部编译成机器码，再执行机器码，按道理来说这样运行效率会更高呀？原因是前期的编译操作是需要一定时间的，特别对于大型的JAVA文件，若前期编译操作浪费大量时间就会影响用户使用体验；而逐条解释虽然效率相对不高，但是能够从快速加载文件，通过牺牲效率换取用户使用体验，从这点来说还是必要的。</p>
<h4 id="3-JVM内存结构"><a href="#3-JVM内存结构" class="headerlink" title="3. JVM内存结构"></a>3. JVM内存结构</h4><p><img src="/images/pasted-3.png" alt="upload successful"></p>
<ul>
<li><p><strong>程序技术器</strong><br>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</li>
<li><p><strong>JAVA虚拟栈</strong><br>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 </p>
</li>
<li><p><strong>本地方法栈</strong><br>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
</li>
<li><p><strong>JAVA堆</strong><br>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
</li>
<li><p><strong>方法区</strong><br>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。<br>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p>
</li>
</ul>
<h3 id="三-JVM的生命周期"><a href="#三-JVM的生命周期" class="headerlink" title="三. JVM的生命周期"></a>三. JVM的生命周期</h3><h4 id="1-JVM的启动"><a href="#1-JVM的启动" class="headerlink" title="1. JVM的启动"></a>1. JVM的启动</h4><p>java虚拟机的启动是通过引导类加载器创建一个初始类来完成的，这个类是由虚拟机的具体实现指定的。初始类加载完成后，再通过main方法将其他的类加载进来。当java程序启动时，JVM进程就被创建和运行。</p>
<h4 id="2-JVM的执行"><a href="#2-JVM的执行" class="headerlink" title="2. JVM的执行"></a>2. JVM的执行</h4><ul>
<li>一个运行中的JVM有着一个清晰的任务： 执行JAVA程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止了。</li>
<li><strong>执行一个所谓的JAVA程序的时候，真真正正在执行的是一个叫JAVA虚拟机的进程。</strong><br>举个例子，我们先执行一段如下代码。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifetime_JVM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a+b;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"good"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序执行未结束时，我们在当前文件夹下使用terminal输入jps，这是一个可以查看java程序运行进程的工具，我们可以看到下图<br><img src="/images/pasted-4.png" alt="upload successful"><br>这里会出现一个Lifetime_JVM的进程，说明jvm已经启动，等程序执行完毕，我们在输入jps时，这个Lifetime_JVM的进程就会消失，如图所示<br><img src="/images/pasted-5.png" alt="upload successful"></p>
<h4 id="3-JVM的退出"><a href="#3-JVM的退出" class="headerlink" title="3. JVM的退出"></a>3. JVM的退出</h4><ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致JAVA虚拟机进程终止。</li>
<li>某线程调用runtime类或者system类的exit访达，或者Runtime类的halt访达，并且JAVA安全管理器也允许这次exit或halt操作。</li>
</ul>
<h3 id="四-参考文章"><a href="#四-参考文章" class="headerlink" title="四. 参考文章"></a>四. 参考文章</h3><p>视频：</p>
<p><a href="https://www.bilibili.com/video/av83622425" target="_blank" rel="noopener">尚硅谷宋红康JVM教程(java虚拟机详解，jvm从入门到精通)</a></p>
<p>文章：</p>
<p><a href="https://juejin.im/post/5d1efae26fb9a07ea6489355" target="_blank" rel="noopener">JVM是什么？深入解析JVM原理!</a></p>
<p><a href="https://blog.csdn.net/sinat_35512245/article/details/54744815" target="_blank" rel="noopener">Java中JVM虚拟机详解</a></p>
<p><a href="https://www.cnblogs.com/ityouknow/p/5610232.html" target="_blank" rel="noopener">jvm系列(二):JVM内存结构</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>My First Post</title>
    <url>/2020/02/24/My-First-Post/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
